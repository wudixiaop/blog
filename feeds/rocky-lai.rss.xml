<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>心亡则忙，亡心则忘</title><link>http://blog.shuiguzi.com/</link><description></description><atom:link href="http://blog.shuiguzi.com/feeds%5Crocky-lai.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 04 May 2015 14:33:00 +0800</lastBuildDate><item><title>瞎聊 Unity3D Shader 系列之六：初识 Shaderlab</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html</link><description>&lt;p&gt;好吧，其实这不算初识 Shaderlab 了，因为在 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;shaderlab 土地上的语言们&lt;/a&gt; 这节中已经说到在 shaderlab 中有三种方式来写 shader。
这节的内容主要是来认识下 shaderlab 语法写出来的 shader 长得什么样子。&lt;/p&gt;
&lt;p&gt;下面有段基于 shaderlab 的 shader 的大概框架的伪代码，在之前要解释下代码中带中括号的部分，如 &lt;code&gt;[Properties]&lt;/code&gt;, 表示是可以选择的，也就是说可以不写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//shader 的名字会显示在 Unity3D 的 Inspector 中选择 shader 的菜单里面&lt;/span&gt;
&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 属性&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Properties&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 可能存在多个 subshader。Unity 会在所有 subshader 列表中选择当前环境中可用的第一个 subshader&lt;/span&gt;
    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// subshader 的标签&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 给多个 pass 公用的设置&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Common&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 可能存在多个 pass, 每个 pass 都会引起一次渲染过程&lt;/span&gt;
        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// pass 的标签&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 渲染设置, 如颜色混合&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Render&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 纹理设置，只有在 fixed function shader 中才可用&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Texture&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 可以有多个 pass&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Pass&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 可以有多个 subshader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Subshader&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当所有 subshader 失败的时候, 使用 Fallback 指定的 shader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Fallback&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当有自定义 shader 的设置 UI 时候用&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CustomEditor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面伪代码中的注释解释了各个部分的作用，如果去除可选部分，最后就留下&lt;strong&gt;精简的骨架&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而大部分 shader 都是在上面代码基础上扩展的。&lt;/p&gt;
&lt;p&gt;这节就到这里，会在后面的章节继续聊 shaderlab。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 04 May 2015 13:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-04:xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html</guid><category>Shader</category></item><item><title>瞎聊 Unity3D Shader 系列之五：RGBA 101</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html</link><description>&lt;p&gt;这节说说 fragment shader 最后输出的像素的颜色表示方法 RGBA。&lt;/p&gt;
&lt;p&gt;玩过 Photoshop 的同学可能知道，存在好几种颜色模式来表示颜色，&lt;a href="http://baike.baidu.com/view/1139658.htm"&gt;比如 RGB 和 CMYK&lt;/a&gt;. 由于显示器的发光物体，所以使用的 RGB 模式。
Unity3D 中也采用这种表示方法。&lt;/p&gt;
&lt;h3&gt;RGB模式&lt;/h3&gt;
&lt;p&gt;RGB是用红绿蓝混合来表示的颜色。R 是红色， G 表示绿色， B 是蓝色。一般用8为来表示一个颜色通道，每个通道有 256 个等级（0~255）。它有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(0, 0, 0)&lt;/code&gt; 表示黑色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(255, 255, 255)&lt;/code&gt; 表示白色&lt;/li&gt;
&lt;li&gt;三个通道数值相同的时候是灰色，比如 &lt;code&gt;(128, 128, 128)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数值越大颜色越亮，反之数值越小越暗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="RGB" src="images/Shader/5/rgb.png" width="61%" /&gt;&lt;/p&gt;
&lt;p&gt;但是 Unity Shader 中并不用 256 个等级来表示颜色数值，而是用标准化（取值0~1）的数值来表示。换句话说就是所有通道都除以 255 得到标准化的结果。&lt;/p&gt;
&lt;h3&gt;RGBA 中的 A 是什么&lt;/h3&gt;
&lt;p&gt;A 叫做 alpha，其数值表示不透明度。 据说提出者用 alpha 来命名源于经典的线性插值方程 αA + (1-α)B 所用的希腊字母 α。Unity3D 中的 aplha blending 基于这个线性方程。&lt;/p&gt;
&lt;h3&gt;混合模式&lt;/h3&gt;
&lt;p&gt;抽象一下就是对两个颜色做运算后得到结果颜色的过程。这个过程其实就是个运算公式。下面列举两个 Photoshop 中常见的正片叠底和滤色两个混合模式的计算公式。C为结果色，A 和 B 是需要混合的颜色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正片叠底(Multiply):&lt;/strong&gt; C=A*B&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滤色(Screen):&lt;/strong&gt; C=1-(1-A)*(1-B)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们要叠加模型多个贴图（比如法线贴图和模型贴图）的时候就可以利用到混合模式。更多混合模式公式参考&lt;a href="http://wenku.baidu.com/view/da9d22d9ad51f01dc281f1f9.html"&gt;这个文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 04 May 2015 13:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-04:xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html</guid><category>Shader</category></item><item><title>瞎聊 Unity3D Shader 系列之四：坐标系</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html</link><description>&lt;p&gt;这节从很平常一段对话开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲跟乙说：&lt;/strong&gt; 喂，你看到那个人没有？&lt;br /&gt;
&lt;strong&gt;乙：&lt;/strong&gt; 你说的是哪个？&lt;br /&gt;
&lt;strong&gt;甲：&lt;/strong&gt; 就是那棵树旁边那个。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从对话里面我们知道：&lt;strong&gt;要描述一个物体的位置，我们需要借助参照物。&lt;/strong&gt; 其实甲也可以这么说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲：&lt;/strong&gt; 在那个个子很高的人左手边那位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说 &lt;strong&gt;参照物是可以选择的，可变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们把上面对话推广到坐标系上，来给坐标系下个山寨的定义：&lt;strong&gt;坐标系是为了描述物体位置而存在，我们借助的参照物是它的原点
。由于可以选择不同的参照物，所以我们可以选择不同的原点。&lt;/strong&gt; 原点很重要，我们利用坐标系的时候首先要知道原点在哪里。&lt;/p&gt;
&lt;p&gt;既然原点可以任意选，那不是说会出现很多坐标系？ 是的，但是我们使用几种约定的坐标系就好了。&lt;/p&gt;
&lt;h3&gt;那些坐标系们&lt;/h3&gt;
&lt;p&gt;下面是我们平时会碰到的一些坐标系。按规定，原点的各个轴是数值都是 0 来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物体坐标系 (Object Space)：&lt;/strong&gt; 有时也叫做 Local Space。是 3D 模型内部的坐标系，原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 一般是模型中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;世界坐标系 (World Space)：&lt;/strong&gt; Unity3D 系统中的绝对坐标系，原点是在场景的 &lt;code&gt;(0，0，0)&lt;/code&gt; 位置处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视口坐标系 (Viewport Space)：&lt;/strong&gt; 以摄像机为原点，朝向为 Z 轴的坐标系。原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 是摄像机的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕坐标系 (Screen Space)：&lt;/strong&gt; 原点 &lt;code&gt;(0, 0)&lt;/code&gt; 在屏幕的左下角，右上角为 &lt;code&gt;(Screen.width，Screen.height)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那问题来了。这些坐标系们有什么关系？&lt;/p&gt;
&lt;p&gt;我们以立方体为例。我们从&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;小节中知道，Mesh Renderer 组件得到模型数据之后它会执行 vertex shader（Unity3d 默认的 Shader 给我提供了）。
vertex shader 里面做了下面这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先把立方体从模型的物体坐标系转换成世界坐标系，&lt;strong&gt;从 物体 到 世界&lt;/strong&gt;。这样子，它和摄像机（世界坐标）的位置就用同一个坐标系描述了。&lt;/li&gt;
&lt;li&gt;再把立方体从世界坐标转换成视口坐标系，也就是摄像机因为原点的坐标系，&lt;strong&gt;从 世界 到 视口&lt;/strong&gt;。这样它是在摄像机的正面，还是在反面了。&lt;/li&gt;
&lt;li&gt;最后在投射到屏幕坐标系上， &lt;strong&gt;从 视口 到 屏幕&lt;/strong&gt;。这样知道哪些区域需要绘制在屏幕上，哪些不需要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结上面一系列变换关系就是： &lt;strong&gt;物体 到 世界 再到 视口 再到 屏幕&lt;/strong&gt;。中间经过了三次变换 (transform)。这些变换在数学上通过 &lt;strong&gt;矩阵&lt;/strong&gt; 来描述的。这里有个知识点：
矩阵可以表示变换。在这里推荐关于 3D 数据的一本经典好书 &lt;a href="http://pan.baidu.com/s/1eQ8eSYQ"&gt;《3D数学基础图形与游戏开发》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;到现在是不是有种跃跃欲试，但是想想又头大的感觉，在 Unity3D 里面这些矩阵具体的数值是什么？要是自己去运算那多复杂啊。别急，Unity3D 给我们已经提供了这些矩阵当作 Shader
的内置变量（&lt;a href="http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html"&gt;详情参考这个链接&lt;/a&gt;），可以在编程的时候直接使用。在这里只是说一下，我们利用 &lt;code&gt;UNITY_MATRIX_MVP&lt;/code&gt;
 这个矩阵就可以达到变换到屏幕坐标系的目的。至于怎么做，会在以后的文章中会提到。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 30 Apr 2015 13:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-30:xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html</guid><category>Shader</category></item><item><title>瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html</link><description>&lt;p&gt;这节是关于 Unity3D 平台上 shader 语言的选择。&lt;/p&gt;
&lt;p&gt;计算机行业的各公司（或者组织）似乎都遵循着某种规则。当他们在某个领域划出了一亩三分地，当上了地主后, 就要用方法圈住干活的农民。让他们觉得在我这里不会饿死，有饭吃，你要到别家
干活的话，需要重头再来，这是一个很亏本的买卖。这个方法就是制定自己体系（软硬件中的各种协议，接口，语言，框架），脱离这套体系，在别的地方玩不起来。开个玩笑来取名这个规矩叫做&lt;strong&gt;圈地规则&lt;/strong&gt;吧。&lt;/p&gt;
&lt;h3&gt;Shader 语言们&lt;/h3&gt;
&lt;p&gt;根据上面提到的圈地规则，下面来隆重的介绍下 shader 这块地上地主们建立起来的体系：CG, HLSL 和 GLSL 语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CG：&lt;/strong&gt; C for Graphics 的简称，是 NVIDIA 公司开发的语言。从名字上来看的出它是 C 语言的亲戚，现实是它保留了 C 语言的大部分语义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HLSL：&lt;/strong&gt; High Level Shader Language 的简称，由微软开发的语言。语法跟 CG 非常的相似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GLSL：&lt;/strong&gt; OpenGL Shading Language 的简称，OPENGL 组件开发的，语法也是基于 C 语言的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么问题来了，Shader 语言到底哪家强？这个也发生过强烈的讨论。&lt;/p&gt;
&lt;p&gt;其实这个问题好回答，既然跟着 Unity3D 地主干，听 Unity3D 地主的话就好了。那么另外一个问题又来了，Unity3D 地主的观点又是什么？&lt;/p&gt;
&lt;h3&gt;Unity3D 体系规则 Shaderlab&lt;/h3&gt;
&lt;p&gt;根据圈地规则，Unity3D 地主也有自己的体系，那就是 Shaderlab。那 shaderlab 又是什么呢？ 这是一个能包容 CG, HLSL 和 GLSL，并且有自己语法体系的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能包容 CG, HLSL, 和 GLSL 意思是说在它里面能使用这三种语言。Shaderlab 中用特定的语法块来指定他们：&lt;ul&gt;
&lt;li&gt;GG 和 HLSL 包括在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;li&gt;GLSL 包括在 &lt;code&gt;GLSLPROGRAM ... ENDGLSL&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有自己的语法系统是指它有自己独特的语法，并且独立于上面三种语言（这句似乎是废话。。。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unity3D 官方比较提倡 CG 或 HLSL 语言。所以我们首选这两个中的其中一个了。之前提到，其实这两语法非常相似，所以其实学好了其中一门就差不多等于学了两门语言。（好像很划算的样子！）&lt;/p&gt;
&lt;h3&gt;在 Shaderlab 中写 Shader 的三种方式&lt;/h3&gt;
&lt;p&gt;Unity3D 手册 Shader 参考章节&lt;a href="http://docs.unity3d.com/Manual/SL-Reference.html"&gt;开篇&lt;/a&gt;就写道 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shaders in Unity can be written in one of three different ways:&lt;/p&gt;
&lt;p&gt;as &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;&lt;strong&gt;surface shaders&lt;/strong&gt;&lt;/a&gt;,&lt;br /&gt;
as &lt;a href="http://docs.unity3d.com/Manual/SL-ShaderPrograms.html"&gt;&lt;strong&gt;vertex and fragment shaders&lt;/strong&gt;&lt;/a&gt; or&lt;br /&gt;
as fixed function shaders.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说有三种 shader 的变体。&lt;/p&gt;
&lt;h4&gt;Fixed function shaders&lt;/h4&gt;
&lt;p&gt;这种 shader 一般用于不支持可编程 shader 模型的老设备上面， 比如 iPhone3。Unity3d 用 shaderlab 的语法来配置。&lt;/p&gt;
&lt;h4&gt;vertex and fragment shaders&lt;/h4&gt;
&lt;p&gt;参考名字，这个主要是玩转 vertex 和 fragment shader 的。参考&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;章节可以知道这两个 shader 处于什么位置。&lt;/p&gt;
&lt;h4&gt;surface shaders&lt;/h4&gt;
&lt;p&gt;Unity3d 提倡如果想写跟光线交互的 shader 使用这种方式写。那 surface shader 又是什么。 &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;Unity 手册里面有段话道出了真相：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Surface Shader compiler then figures out what inputs are needed, what outputs are filled and so on, &lt;strong&gt; and generates actual vertex&amp;amp;pixel shaders,&lt;/strong&gt;
as well as rendering passes to handle forward and deferred rendering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来 surface shader 最终会被编译成 vertex&amp;amp;fragment shader，这只是换了个汤。当然汤里家里点佐料就是 Unity 帮你处理光线而不用自己写算法。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;Unity3D Shaderlab 是基于shader语言上建立了自己的一套语法规则，我们不仅要学习 shaderlab 语法，也要学习 shader 语言。Unity3D 官方提倡使用 CG 或 HLSL 语言。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.unity3d.com/Manual/ShadersOverview.html"&gt;Unity3d Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1rsaho"&gt;GPU 编程与CG 语言之阳春白雪下里巴人&lt;/a&gt;（点击链接即可下载），推荐此书。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 04 May 2015 14:33:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-29:xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html</guid><category>Shader</category></item><item><title>瞎聊 Unity3D Shader 系列之二：渲染管线</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html</link><description>&lt;p&gt;这节描述的是图形渲染的大致过程。&lt;/p&gt;
&lt;p&gt;为了更好理解和记忆这节内容，先来学下面几个词。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染管线(Rendering Pipeline)：&lt;/strong&gt; 一提到管线，感觉很高大上的样子。说的俗一点就是可以理解为流水线。渲染管线我们可暂时理解为 &lt;strong&gt;从得到模型数据到绘制出图像&lt;/strong&gt; 这一过程的称呼。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vertex Shader：&lt;/strong&gt; 对顶点数据编程的一段程序。 人类有懒惰的天性，习惯用简化的词汇来表达同一个东西。对 Vertex Shader 也不例外，一般称其为 VS ，但是在本系列文章中会保持全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fragment Shader：&lt;/strong&gt; 对像素数据编程的一段程序。这里 fragment 可以理解为带有信息（颜色，坐标等）的像素 (Pixel), 一般也简称其为 FS 或者 PS 。 在本系列文章中会保持其全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FrameBuffer：&lt;/strong&gt; 缓存帧数据的存储区，它一般包含的是要显示到显示设备上的位图数据（也就是图片数据）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fixed Function：&lt;/strong&gt; 由于一些硬件支持等历史原因，早期的图形 API  &lt;strong&gt;只支持对 GPU 做配置&lt;/strong&gt;，这部分只可配置的功能就是 fixed fucntion。
这里注意下，fixed function 的功能只能配置，不像 Vertex Shader　和 fragment Shader 可以编程（写自己的算法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染管线 (Rendering Pipeline)&lt;/h3&gt;
&lt;p&gt;看图说话&lt;/p&gt;
&lt;p&gt;&lt;img alt="2.renderingpipeline.jpg" src="images/Shader/2/rendering-pipeline.jpg" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;上面是可编程的渲染管线模型的示意。下面多说几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入阶段。Unity3D 使用 Mesh Renderer 等组件读取模型顶点数据，然后调用图形 API，将数据传递给 GPU。&lt;/li&gt;
&lt;li&gt;现实中同时会进行多条渲染管线，他们是&lt;strong&gt;并行的&lt;/strong&gt;。 这点概念比较重要，以后还会提到它。我们记住 GPU 并行能力很强。&lt;/li&gt;
&lt;li&gt;最后输出的 FrameBuffer (可以理解为渲染出来的图片) 有几率被抛弃掉，也就是说不显示在显示设备上。这个以后单独说明原因。好比残酷的现实世界，努力了（整个渲染过程）也不一定会成功（被显示出来）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;渲染管道是从得模型数据到图像生成过程的一种描述。Vertex Shader 能对顶点数据写处理算法，而 Fragment Shader 能对像素数据写处理算法。&lt;/p&gt;
&lt;h3&gt;参考：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikibooks.org/wiki/Cg_Programming/Programmable_Graphics_Pipeline"&gt;Cg Programming in Unity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fixed-function"&gt;Fixed-function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 28 Apr 2015 14:07:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-28:xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html</guid><category>Shader</category></item><item><title>瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model</title><link>http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</link><description>&lt;p&gt;我想首先唠叨下我为什么打算写这一系列的文章及文章的定位。&lt;/p&gt;
&lt;p&gt;我写的动力主要来源于如下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对之前学习的一些总结、复习和提炼&lt;/li&gt;
&lt;li&gt;尽可能的填充一些概念上的空白。 有不少关于 Unity3D shader 的文章只讲 Shaderlab 语法，讲各种光照模型等, 这对于缺乏概念的新手来说是不太好理解的。&lt;/li&gt;
&lt;li&gt;之前信誓旦旦的跟朋友说以后学了 shader 会写点文章出来，算是允诺。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章定位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是学习笔记，不是教程。如果内容会有出入，非常感谢和希望您能指正。&lt;/li&gt;
&lt;li&gt;主要基础概念为主，可能很零散。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前有前辈说过，学习一门知识前，了解其由来对入门很有好处。我比较赞同这个观点，所以开篇我们来说写历史。&lt;/p&gt;
&lt;h3&gt;CPU 之外的另外一个 PU - GPU&lt;/h3&gt;
&lt;p&gt;随着计算机处理图形的计算量越来越来大，CPU难以满足计算速度上的需求, 为了将图形的计算单独拿出来执行，上世纪70年代开始出现了为加速图形绘制的硬件。
这些硬件跟大部分刚出来的新事物一样，功能有限，而且不太完善，当然那个时候也不叫 GPU。&lt;/p&gt;
&lt;p&gt;1999 年，NVIDIA 公司发布了 GeForce256, 并且提出一个 Graphics Process Unit (GPU) 概念。很多文章都提到这款显卡有划时代的意义，因为它使第一款
带有可编程顶点处理能力的显卡，这意味着显卡从&lt;strong&gt;之前的只可配置&lt;/strong&gt;上升到了&lt;strong&gt;可编程&lt;/strong&gt;的高度，开发者从此可以实现自己顶点处理算法。NVIDIA 也是提出 GPU 这个词
来对 GeForece256 与之前显卡做区分。&lt;/p&gt;
&lt;p&gt;2000 年以后， GPU 技术一直在不断的发展，处理和运算能力不断打变强变大。为了利用 GPU 强大的并行计算能力，出现了 CUDA 并行计算平台。有兴趣的同学可以关注下
&lt;a href="https://developer.nvidia.com/cuda-zone"&gt;CUDA官网&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Shader Model&lt;/h3&gt;
&lt;p&gt;首先我们要提下当今跟 GPU 打交道的形API：&lt;a href="http://en.wikipedia.org/wiki/DirectX"&gt;Microsoft DirectX&lt;/a&gt;、 &lt;a href="https://www.opengl.org"&gt;OPENGL&lt;/a&gt; 和
 转为嵌入式设备设计的&lt;a href="https://www.khronos.org/opengles/"&gt;OPENGL GS&lt;/a&gt;。Directx 是微软提供的图形 API, OPENGL 和 OPENGL ES 现在是由 &lt;a href="http://baike.baidu.com/link?url=vW0PfmVKQC00WWRibyVSrnjRYVdVj1lk9HG6B4w9uc9lnlnWnYoDJd1puZu1CNf2_vacBBTFFbdMzZWCNkliSK"&gt;Khronos Group&lt;/a&gt; 团队维护开发的图形API。&lt;/p&gt;
&lt;p&gt;这些图形 API 都提供对 GPU 编程的能力，这能力就是我们说的 Shader。图形 API 的更新会提供不同的 shader 的能力 (当然是越来越强大)。
微软提出了一个词叫 Shader Model, 并用不同的版本号来区分 Shader 的能力。通常我们也会称 Shader Model 为 SM。&lt;/p&gt;
&lt;p&gt;下面列出到现在为止 Shader Model 的各个版本与 DirectX 版本的对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shader Model 1.0（DirectX8.0）&lt;/li&gt;
&lt;li&gt;Shader Model 2.0（DirectX9.0b）&lt;/li&gt;
&lt;li&gt;Shader Model 3.0（DirectX9.0c）&lt;/li&gt;
&lt;li&gt;Shader Model 4.0（DirectX10）&lt;/li&gt;
&lt;li&gt;Shader Model 4.1（DirectX10.1）&lt;/li&gt;
&lt;li&gt;Shader Model 5.0（DirectX11）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先不关注各个版本区别，只要知道版本号越高，提供的功能越来越强大。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;GPU 为大量图形计算而生，而 Shader 是对 GPU 编程的技术。微软用 Shader Model 的不同版本号来区分不同 Shader 的能力。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphics_processing_unit"&gt;Wikipidia: Graphics processing unit &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/gp/product/1568814240?tag=realtimerenderin&amp;amp;pldnSite=1"&gt;&lt;em&gt;Real-Time Rendering, Third Edition&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/link?url=DDy0sTi56RE9TiVdj5MOCqwmV7ATJEkBHQp7V8eRzA_lyq1HPOLgmBULeSo-Khw2-mb7Wst75LJF3_I3SjZAZa"&gt;Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 27 Apr 2015 15:54:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-26:xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</guid><category>Shader</category></item><item><title>在Unity3d uGUI中绘制圆形图片</title><link>http://blog.shuiguzi.com/zai-unity3d-uguizhong-hui-zhi-yuan-xing-tu-pian.html</link><description>&lt;p&gt;最近项目需要在 Unity3D 的新 UI 系统中实现圆形头像的功能，之前想通过 Mask 控件的方式来实现，但是一番努力后毫无头绪，只能祭上shader了。&lt;/p&gt;
&lt;p&gt;大体的思路就是在一个空的 Object 上面挂上 RawImage 组件，组件的 Material 挂上本文中的 shader。截取的逻辑是选取图片正中心 (0.5, 0.5) 为圆的中心点，绘制图片在圆内的像素点为图片的像素，然后图片在圆外的像素点设置为 alpha 为 0 的点，
如 &lt;code&gt;(0, 0, 0, 0)&lt;/code&gt;。逻辑是在 fragment shader 里面实现(shader 代码中的&lt;code&gt;frag&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下面直接放出 shader:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Sprites/Circle&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Properties&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PerRendererData&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sprite Texture&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;_Color&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Tint&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Center&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Radius Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Horizontal Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
    &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vertical Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;SubShader&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Tags&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;Queue&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Overlay&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;IgnoreProjector&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Transparent&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;PreviewType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Plane&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;CanUseSpriteAtlas&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Cull&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Lighting&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;ZWrite&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Blend&lt;/span&gt; &lt;span class="n"&gt;One&lt;/span&gt; &lt;span class="n"&gt;OneMinusSrcAlpha&lt;/span&gt;

    &lt;span class="n"&gt;Pass&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma vertex vert&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma fragment frag&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma multi_compile _ PIXELSNAP_ON&lt;/span&gt;
      &lt;span class="cp"&gt;#include &amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;appdata_t&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;v2f&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;half2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="nf"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;appdata_t&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNITY_MATRIX_MVP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="cp"&gt;#ifdef PIXELSNAP_ON&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnityPixelSnap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="cp"&gt;#endif&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="n"&gt;sampler2D&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;frag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_Target&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tex2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// adjust center and horizontal/verital scale&lt;/span&gt;
        &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;

          &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;ENDCG&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Github 地址： &lt;a href="https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader"&gt;https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 15 Apr 2015 23:30:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-15:zai-unity3d-uguizhong-hui-zhi-yuan-xing-tu-pian.html</guid><category>Unity3D</category></item><item><title>一个例子学习Swift中的闭包用法</title><link>http://blog.shuiguzi.com/yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</link><description>&lt;p&gt;初学习Swift, 觉得Swift中的闭包用法比较灵活, 所以在学习的时候编了个小例子来把用法罗列了出来, 分享出来给大家。&lt;/p&gt;
&lt;p&gt;在讲例子之前我们来看下什么是闭包(Closure).《The Swift Programming Language》是这样定义的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Closures are self-contained blocks of functionality that can be passed around and used in your code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文版中这样翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看解释我们知道，闭包是代码段，它能实现一些逻辑（函数），它可以被传递和使用（就像类型一样）。&lt;/p&gt;
&lt;p&gt;然后我们来看看闭包长的什么样子。下面是闭包的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ (parameters) -&amp;gt; returnType in
   statements
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面定义中 &lt;strong&gt;parameters&lt;/strong&gt; 是指参数， &lt;strong&gt;returnType&lt;/strong&gt; 是返回类型，而 &lt;strong&gt;statements&lt;/strong&gt; 指的是我们要实现的逻辑的代码, 闭包的代码都被 &lt;strong&gt;{}&lt;/strong&gt; 包含着。
观察力强的同学们估计发现了，它怎么跟Swift的函数长的差不多，难道它们是亲戚? Swift中函数是一种特殊的闭包，记住函数是闭包，不是闭包是函数哦。&lt;/p&gt;
&lt;p&gt;接下来我们说说文章开头提到的那个栗子。&lt;/p&gt;
&lt;p&gt;假设我们要找出某一些人中最小年龄是多少，我们要通过排序的方法来得到这个年龄。有这么一组年龄数字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;ages&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先我们使用最原始的办法，自己定义排序方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中我们定义了一个叫做 sortAge 的函数, 它传递给了第二个参数的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Bool&lt;/code&gt; 的 sorted 函数。 如果用闭包来代替自定义的函数, 写法就变成了这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个闭包用法就写好了。上面闭包中，定义了参数的个数，名字还有其类型，定义了返回值，还有代码体(in 关键词之后的代码)。
看起来就像重新写了一个 sortAage 函数。你可能会想，这样也没省多少事，只不过是把自定义的函数写到了 sorted 函数的参数里而已。
别急, 学会聪明的偷懒是一个好程序员属性，我们来看看怎么简化上面的代码。&lt;/p&gt;
&lt;p&gt;首先&lt;strong&gt;闭包中如果能从上下文推断出其参数类型，我们可以省略其类型的定义&lt;/strong&gt;。sorted 函数的, 所以我们可以简化代码为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，用来包含参数的括号我们可以省略掉, 变成了下面这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包代码体中只包含单行代码, 我们可以省略 return 关键词&lt;/strong&gt;, 然后变成了这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包中返回类型能从上下文推断出，我们可以省略返回值定义&lt;/strong&gt;。参照上面 sorted 函数第二个参数的定义，是可以推断出闭包返回值是 Bool。省略之后就变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到了这里，代码已经比较清爽了。但是偷懒的步伐还可以继续（懒惰是人类文明进化的动力）。Swift 闭包中允许用 $0, $1 $2 这样用 $n 这种符号后面接数字的形式来表示其第n个参数. 然后就可以变成这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，已经很短了。人类的偷懒的方法是无止境的。Swift中定义了运算符函数 &lt;code&gt;&amp;gt;&lt;/code&gt;, 我们可以把它传递给 sorted 函数。于是乎变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你还想问有没有更偷懒的方法？我只想说，兄台你醒醒吧，都只要输入一个字符而已了，你还要怎么样。。。&lt;/p&gt;
&lt;p&gt;除了上面的一些用法外，还有一种叫做尾随闭包（就是跟在调用它的函数的屁股后面的闭包），当调用它的函数的最后一个参数是闭包时，可以使用。我们可以把&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成尾随闭包形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大概就这些。。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 26 Mar 2015 15:37:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-03-26:yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</guid><category>Swift</category></item><item><title>如何在Github for Mac/Windows上使用非Github的仓库</title><link>http://blog.shuiguzi.com/ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</link><description>&lt;p&gt;你或许跟我一样，不想花太多时间去"精通"git的各种命令，想用简单明了的方法来玩git。而Github的客户端恰是这种良药。使用过的童鞋可能有过跟我一样困惑：Github客户端在界面上只能管理Github的代码仓库，怎么才能管理非Github的仓库呢？&lt;/p&gt;
&lt;p&gt;这个问题也就是本文要解决的内容。先讲Github for Mac, 然后是Github for Windows&lt;/p&gt;
&lt;h3&gt;Github for Mac&lt;/h3&gt;
&lt;p&gt;首先创建一个本地的仓库, 假设取名为&lt;strong&gt;Freekick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_1" src="images/GitClient/mac_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后把git仓库的https地址设置为&lt;strong&gt;Freekick&lt;/strong&gt;仓库的&lt;strong&gt;Primary remote repository&lt;/strong&gt;。在&lt;strong&gt;Settings&lt;/strong&gt;选项卡中设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_2" src="images/GitClient/mac_2.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;上一步完成之后点击&lt;strong&gt;Updae Remote&lt;/strong&gt;按钮，之后会弹出输入账号密码的对话框。输入正确的账号密码即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_3" src="images/GitClient/mac_3.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后切换到&lt;strong&gt;Changes&lt;/strong&gt;选项卡，点击右上角的&lt;strong&gt;publish&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_4" src="images/GitClient/mac_4.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;最后Github for Mac会自动同步仓库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_5" src="images/GitClient/mac_5.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;Github for Windows&lt;/h3&gt;
&lt;p&gt;在Windows上只需要把git仓库的https地址拖拽到Github for Windows客户端上，然后会弹出对话框。输入正确的账号密码后，Github for Windows会自动同步代码。拖拽的时候最好把浏览器窗户缩小，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="windows_1" src="images/GitClient/windows_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;Github客户端不能本地创建新的仓库，然后发布到除Github之外的代码托管服务器上。如果需要新建一个仓库，我们可以先创建好一个空的新仓库，然后再用本文提到的方法来同步仓库来达到目的。&lt;/p&gt;
&lt;p&gt;另外，由于Github客户端是为Github量身定做的，当管理非Github仓库时，会有少量跟github相关的功能不能用。但是个人觉得这个不影响体验。我们可以通过下面的地址在官方下载Github客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github for Windows:&lt;/strong&gt; &lt;a href="https://windows.github.com/"&gt;https://windows.github.com/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Github for Mac:&lt;/strong&gt; &lt;a href="https://mac.github.com/"&gt;https://mac.github.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 28 Jan 2015 16:54:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-01-28:ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</guid><category>Git</category></item><item><title>从C#到Python</title><link>http://blog.shuiguzi.com/cong-cdao-python.html</link><description>&lt;p&gt;项目组最近可能要用Python写一插件，虽然自己只是会用，但是还是被要求给大家做个简单的Python入门培训。只能冲个胖子，硬着头皮上了。
由于项目组里大部分童鞋们都会C#，可能如果从C#做类比的角度来阐述Python语法会更好点，然后下面奇怪的Python教程出来了。大家可以在这里得到PPT和代码:  &lt;a href="https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start"&gt;https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是讲语法的代码，语法部分在注释中有描述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- encoding:utf-8 -*-&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;本代码主要展示Python的基本数据类型和语法, 及其用法，希望可以帮助大家快速入门。&lt;/span&gt;
&lt;span class="sd"&gt;如果不是C#程序员, 请忽略‘C#伪代码’, 直接通过参考‘Python规则’部分来学习&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;




&lt;span class="c"&gt;# ---------------------------------注释----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 注释&lt;/span&gt;

&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    1. 用#打头表示注释&lt;/span&gt;
&lt;span class="sd"&gt;    2. 用三引号的字符串块，也可以表示注释（因为编译器会忽略3引号的块）&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;



&lt;span class="c"&gt;# -----------------------------------赋值-------------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 赋值&lt;/span&gt;

&lt;span class="sd"&gt;Python规则: &lt;/span&gt;
&lt;span class="sd"&gt;    Python是动态语言，变量类型在赋值阶段决定，不像其他语言一样需要先声明变量的数据类型(如C#).&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码: &lt;/span&gt;
&lt;span class="sd"&gt;    string var_sample = &amp;quot;something&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_sample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;someting&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#变量var_sample是字符串类型&lt;/span&gt;




&lt;span class="c"&gt;# ------------------------------Python基本数据类型-----------------------------------------------&lt;/span&gt;
&lt;span class="c"&gt;#   1. 空, 用None表示。&lt;/span&gt;
&lt;span class="c"&gt;#   2. 布尔类型: &lt;/span&gt;
&lt;span class="c"&gt;#   3. 数值类型。&lt;/span&gt;
&lt;span class="c"&gt;#   4. 字符串&lt;/span&gt;
&lt;span class="c"&gt;#   5. 列表, 也就是数组。&lt;/span&gt;
&lt;span class="c"&gt;#   6. 字典&lt;/span&gt;
&lt;span class="c"&gt;#   7. 集合(set)，无序的，不重复的元素集。&lt;/span&gt;
&lt;span class="c"&gt;#   8. 元组(Tuple), 和列表类似，但是一旦初始化就不能改变。&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 空  -----------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    空类型用None表示, 类似C#中的null.&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T s = null; // T表示可空类型&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_none&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 布尔类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    True和False. 对应C#中的true和false。&lt;/span&gt;
&lt;span class="sd"&gt;    基本类型中空、任何数值类型中的0、空字符串、空元组()、空列表[]、空字典{}都被当作 False.&lt;/span&gt;
&lt;span class="sd"&gt;    布尔运算有3中not, and和or, 他们的优先级是 not &amp;gt; and &amp;gt; or&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool1 = true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool2 = false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool3 = 3 &amp;gt; 2;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool4 = !true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool5 = true &amp;amp;&amp;amp; true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool6 = true || false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool7 = false || ((!false) &amp;amp;&amp;amp; true);&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_bool1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;        &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;    &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# 变量值为 True&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 数值类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    数值类型包括整型(int)和浮点数(float)&lt;/span&gt;
&lt;span class="sd"&gt;    整型前缀0b表示二机制，0O表示八进制，0X表示十六进制&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    int var_int = 1;&lt;/span&gt;
&lt;span class="sd"&gt;    int var_binary = Convert.ToInt32(&amp;quot;0010&amp;quot;, 2);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_octal = Convert.ToInt32(&amp;quot;0010&amp;quot;, 8);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_hex = 0x0010;&lt;/span&gt;
&lt;span class="sd"&gt;    double var_float = 1.0; // 或者 float var_float = 1.0;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;var_binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;b0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为2&lt;/span&gt;
&lt;span class="n"&gt;var_octal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;O0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为8, 0O第二个是字母O&lt;/span&gt;
&lt;span class="n"&gt;var_hex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为16&lt;/span&gt;
&lt;span class="n"&gt;var_float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 字符串  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字符串有多种表示方法，可以是&lt;/span&gt;
&lt;span class="sd"&gt;    1. 单引号&lt;/span&gt;
&lt;span class="sd"&gt;    2. 双引号&lt;/span&gt;
&lt;span class="sd"&gt;    3. 三引号, 字符串块，如果没有赋值给变量，会被编译器忽略，在这种情况下可以拿来当注释用&lt;/span&gt;

&lt;span class="sd"&gt;    字符串可以带r前缀，表示raw string, 不用转义&lt;/span&gt;
&lt;span class="sd"&gt;    字符串可以带u前缀，表示Unicode编码&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str2 = &amp;quot;some string&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str3 = @&amp;quot;C:\mydir\file.txt&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str4 = @&amp;quot;C:\mydir\文件.txt&amp;quot;; &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;var_str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some string&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;r&amp;quot;C:\mydir\file.txt&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;&amp;quot;&amp;quot;C:\mydir\文件.txt&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;#下面两种字符串格式是等价的&lt;/span&gt;
&lt;span class="n"&gt;var_str_fromat1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;var_str_format2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{0} {1}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 列表  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    列表，即数组, 用[]表示, 可以包含不同类型的元素。 C#中的数组或者List&amp;lt;&amp;gt;与其类似，但是C#必须指明元素数据类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的数组或List&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;  &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;       &lt;span class="c"&gt;# 索引下标从0开始，这段代码把第2位元素赋值为字符串&amp;#39;2&amp;#39;，取代了原来的整型2. 此时var_list值为 [1, &amp;#39;2&amp;#39;, [3]]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 添加一元素，此时var_list值为 [1, &amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 删除一元素，从头遍历，删除第一个元素1, 此时var_list值为 [&amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 继续删除1， 此时var_list值为 [&amp;#39;2&amp;#39;, [3]]&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 字典  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字典，用{}表示，可以用不同的类型做key和value, key和value之间用:号连接&lt;/span&gt;
&lt;span class="sd"&gt;    C#中的Dictionary&amp;lt;&amp;gt;和这个类似，但是C#必须指明Key和Value的类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的Dictionary&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello dictionary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 通过Key访问元素&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c"&gt;# 删除已元素，用del关键词&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 集合  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    集合(set)，是一个无序的，元素不重复的集，元素可以是不同类型。C#中的HashSet&amp;lt;&amp;gt;和这个类似，但是C#中必须指定类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的HashSet&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素, 此时var_set值为 set([1, &amp;#39;2&amp;#39;])&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 元组 -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    元组(Tuple), 用()表示，能包含不同类型元素。 和列表类似，但是一旦初始化就不能改变。C#中的Tuple&amp;lt;&amp;gt;和这个类似&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;   Tuple&amp;lt;int, int&amp;gt; var_tuple = new Tuple&amp;lt;int, int&amp;gt;(10, 20); &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_tuple_item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_tuple&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# 访问item, 下标从0开始&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------循环控制-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    python支持for和while循环&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    for(int i; i &amp;lt; 10; i ++) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        // do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    foeach(var item in List) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    int count = 0;&lt;/span&gt;
&lt;span class="sd"&gt;    while (count &amp;lt; 10)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        count += 1;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;


&lt;span class="c"&gt;# ------------------------------条件判断-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    条件判断 if, if-else, if-elif-else，或者包含多个elif的if-elif-elif...-else, 每个关键词后要带冒号&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    if (3 &amp;gt; 2) {}&lt;/span&gt;

&lt;span class="sd"&gt;    if (3 &amp;lt; 2)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    if ( 3 &amp;lt; 2 )&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 3)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 4)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------异常处理-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    关键词try...excpet&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       int i = 1/0; &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch(ZeroDivisionError)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ZeroDivisionError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------函数-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    函数用def来声明&lt;/span&gt;
&lt;span class="sd"&gt;    没有返回值声明，返回值由函数语句中的return来指明，并且可以有多个返回值。&lt;/span&gt;
&lt;span class="sd"&gt;    参数不需要带类型名字&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以赋值给变量&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以嵌套&lt;/span&gt;

&lt;span class="sd"&gt;    特别关注： 一些函数会用 *args和 **kwargs当作参数来表示可变参数：&lt;/span&gt;
&lt;span class="sd"&gt;        * --  以元组作为参数传入&lt;/span&gt;
&lt;span class="sd"&gt;        ** -- 以字典做为参数传入&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T test_function&amp;lt;T&amp;gt;(T a, T b)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        return a + b;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#的return 没有多返回值，且可变参方法不支持不同类型，这里不提供类比代码&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    按照python的风格，方法的注释用三引号字符块表示，并且方法函数声明与其&lt;/span&gt;
&lt;span class="sd"&gt;    第一行语句中间&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;var_test_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_function&lt;/span&gt; &lt;span class="c"&gt;# 函数可以赋值给变量&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 返回3&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回&amp;#39;12&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多个返回值&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    参数不确定时&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="n"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;上面语句输出为:&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;tuple&amp;#39;&amp;gt; (1, [1, &amp;#39;2&amp;#39;], 2)&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;dict&amp;#39;&amp;gt; {&amp;#39;a&amp;#39;: 3, &amp;#39;b&amp;#39;: [1, 2, 4, 5]}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# ------------------------------面向对象-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则&lt;/span&gt;
&lt;span class="sd"&gt;    类用关键词class表示&lt;/span&gt;
&lt;span class="sd"&gt;    类可以继承，并且支持多继承&lt;/span&gt;
&lt;span class="sd"&gt;    类的构造函数名字是固定的，名字是__init__, init前后是两个下划线&lt;/span&gt;
&lt;span class="sd"&gt;    类的析构函数名字也是固定的，名字是__del__&lt;/span&gt;
&lt;span class="sd"&gt;    实例方法第一参数名字必须是self,用于传递对象本身&lt;/span&gt;
&lt;span class="sd"&gt;    静态方法用@staticmethod装饰器表示，类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;    类方法用@classmethod装饰器表示，类似于C#中的类的静态方法&lt;/span&gt;
&lt;span class="sd"&gt;    子类同名的方法会覆盖父类同名方法&lt;/span&gt;
&lt;span class="sd"&gt;    多继承中，如果不同父类有有相同明名字的字段，则其值为最近一次所赋的值。&lt;/span&gt;

&lt;span class="sd"&gt;c#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    class Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public string msg;&lt;/span&gt;


&lt;span class="sd"&gt;        public Base(string msg)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            this.msg = msg;&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_class()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.Writeline(this.msg);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print something from Base&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    class Child : Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public Child : base(&amp;quot;Child&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;

&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public override void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print someting from Child&amp;quot;);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#不支持类的多继承&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        方法的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;        __init__()是构造函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        析构函数, 一般很少用&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base  {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;print something from Base&amp;#39;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    单继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        与父类同名，会覆盖父类的print_somthing方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print someting from Child&amp;quot;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base2 {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        静态方法, 要带@staticmethod装饰器, 类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;statc methond in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thiscls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        类方法，要带@classmethod装饰器，类似C#中的类的静态方法, 带一个参数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;class_method in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        访问父类方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access static methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access class methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access instance methond in parent class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类测试方法&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="c"&gt;# 多继承时，&lt;/span&gt;
    &lt;span class="c"&gt;#  1. 当不同的父类有相同的字段时, 其值为最近一次所赋的值&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="c"&gt;#  2. 当不同父类有相同方法时, 执行继承列表中的第一个父类的方法&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------模块与包-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    导入模块或包有好几种方式&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入：  import [moudle_name or package_name]&lt;/span&gt;
&lt;span class="sd"&gt;使用时要带上module_name或者package_name&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;module&lt;/span&gt;
&lt;span class="c"&gt;#print module.get_module_name()&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt;
&lt;span class="n"&gt;SamplePackage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addmodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种一： from [moudle_name or package name] import [...]&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;modemodule&lt;/span&gt; 
&lt;span class="n"&gt;modemodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种二： from [moudle_name or package name] import *  &lt;/span&gt;
&lt;span class="sd"&gt;*表示导入所有&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage.multiplymodule&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;__name__ 在默认情况下：&lt;/span&gt;
&lt;span class="sd"&gt;    1. 如果被自己模块内调用，它的值是 __main__&lt;/span&gt;
&lt;span class="sd"&gt;    2. 如果在外部模块调用，他的值是模块名字&lt;/span&gt;

&lt;span class="sd"&gt;所以我们可以把模块内部的测试代码放到下面代码中，不会影响其他模块&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码地址: &lt;a href="https://github.com/wudixiaop/Nana/blob/master/Python/Tutorial/Python%20Quick%20Start/PythonQuickStart/Python_Introduction.py"&gt;Github&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 07 Jan 2015 20:13:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-01-07:cong-cdao-python.html</guid><category>Python</category></item><item><title>如何在Visual Studio中愉快的玩耍</title><link>http://blog.shuiguzi.com/ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</link><description>&lt;p&gt;好吧，其实我想要说一些我觉得可以在Visual Studio中提高效率的经验。下面直接进入正题：&lt;/p&gt;
&lt;h2&gt;熟记并使用各种快捷键&lt;/h2&gt;
&lt;p&gt;快捷键之所以叫快捷键就是因为它会让事情变得更快捷。好吧，其实我知道前面一句废话。下面就列举一些碰上常用的(基于Visual C# 2005快捷键映射)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注释: &lt;strong&gt;Ctrl + E, C&lt;/strong&gt; (也就是，先&lt;strong&gt;Ctrl&lt;/strong&gt;和&lt;strong&gt;E&lt;/strong&gt;一起摁，然后摁&lt;strong&gt;C&lt;/strong&gt;. 下面碰到有带组合键的情况类似)&lt;/li&gt;
&lt;li&gt;取消注释: &lt;strong&gt;Ctrl + E, U&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整行剪切: &lt;strong&gt;Ctrl + X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开光标所在行的概述(Outlining): &lt;strong&gt;Ctrl + M, M&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起概述(Outlining)到定义: &lt;strong&gt;Ctrl + M, O&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开所有概述(Outlining): &lt;strong&gt;Ctrl + M, L&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;呼出自动补全窗口: &lt;strong&gt;Ctrl + J&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;回跳到光标上一次所在位置: &lt;strong&gt;Ctrl + -&lt;/strong&gt; (这是减号)&lt;/li&gt;
&lt;li&gt;MSDN帮助: &lt;strong&gt;F1&lt;/strong&gt; (光标移到类名或者方法名上，然后摁&lt;strong&gt;F1&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;运行: &lt;strong&gt;F5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;编译: &lt;strong&gt;F6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;调试时Step Over/In: &lt;strong&gt;F10&lt;/strong&gt;/&lt;strong&gt;F11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跳转到定义: &lt;strong&gt;F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;搜索和替换窗口: &lt;strong&gt;Ctrl + Shift + F&lt;/strong&gt; 或者 &lt;strong&gt;Ctrl + Shift + H&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当然还有超级好用的自能感应: &lt;strong&gt;Ctrl + .&lt;/strong&gt; (或者&lt;strong&gt;Ctrl + Shift + F10&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然还有很多其他快捷，但是平时自己用的少，就不列举了。&lt;/p&gt;
&lt;h2&gt;偷懒技巧一：使用代码片段管理器(Code Snippets Manager)&lt;/h2&gt;
&lt;p&gt;如果还不知道有这个东西的童鞋可以在Vistual Studio的工具菜单中找到。具体怎么用大家可以参照别的童鞋们的文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/cyq1162/archive/2013/06/14/3135373.html"&gt;Visual Studio 小技巧：自定义代码片断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kb.cnblogs.com/page/42164/"&gt;使用Visual Studio Snippet(片断)提交开发效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单一句话描述Code Snippets使用就是：如果用C#举例，编写代码的时候，输入代码片段的快捷键(比如for), 然后摁两下Tab键，接下来就知道怎么做了。&lt;/p&gt;
&lt;p&gt;按惯例，列举一些C#常用的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;循环: &lt;strong&gt;for&lt;/strong&gt;, &lt;strong&gt;foreach&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成类: &lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成构造函数: &lt;strong&gt;ctor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成属性: &lt;strong&gt;prop&lt;/strong&gt;, &lt;strong&gt;propfull&lt;/strong&gt;, &lt;strong&gt;propdp&lt;/strong&gt;(Wpf系列中的依赖属性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;偷懒技巧二: Toolbox&lt;/h2&gt;
&lt;p&gt;文字看多了，咱们来看视频吧&lt;/p&gt;
&lt;iframe src="//channel9.msdn.com/Series/vstips/lazycodesnippets/player?format=html5" allowFullScreen frameBorder="0"&gt;&lt;/iframe&gt;

&lt;p&gt;视频源地址：&lt;a href="http://channel9.msdn.com/Series/vstips/lazycodesnippets"&gt;http://channel9.msdn.com/Series/vstips/lazycodesnippets&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;成为高手~~&lt;/h2&gt;
&lt;p&gt;不想成为标题党的程序员不是一个好写手。好吧，其实我是来推荐&lt;strong&gt;VsVim&lt;/strong&gt;这个插件的。。。&lt;/p&gt;
&lt;p&gt;首先，我们需要安装&lt;strong&gt;VsVim&lt;/strong&gt;。童鞋们可以在VS工具菜单下的扩展及更新(Extension and Updates)里查找并安装。具体可以参照这篇文章: &lt;a href="http://www.tuicool.com/articles/YF7RNv"&gt;http://www.tuicool.com/articles/YF7RNv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后开始练技能打怪练级:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://coolshell.cn/articles/5426.html"&gt;http://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jaredpar/VsVim/wiki/faq"&gt;https://github.com/jaredpar/VsVim/wiki/faq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再然后会慢慢发现平时编码时摸鼠标的次数越来少。。。&lt;/p&gt;
&lt;p&gt;再然后。。。没有再然后了。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 24 Dec 2014 14:50:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-12-24:ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</guid><category>Visual Studio</category></item><item><title>一起看看MonoBehavior内部事件执行顺序</title><link>http://blog.shuiguzi.com/yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html</link><description>&lt;h3&gt;&lt;strong&gt;写在最前面&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;或许对于大部分Unity3D程序员来说，第一次接触脚本编写的时候都是从MonoBehavior开始的。MonoBehavior是Uniy3d脚本编写核心的类之一， 它预先定义好了很多事件，并且这些事件按照预先定义好顺序执行。了解MonoBehavior提供的这些事件的执行顺序，是我们进一步提高脚步编程和了解Unity3D内部逻辑的必要一步。我们先从MonoBehavior提供的事件说起。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;MonoBehavior都提供了什么事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MonoBehavior提供的事件从编辑器到游戏结束都有涉及。下面列举一些常用的，更详列表可以参照&lt;a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html"&gt;这个页面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与编辑相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Reset&lt;/td&gt;
            &lt;td&gt;Reset to default values.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;FixedUpdate&lt;/td&gt;
            &lt;td&gt;This function is called every fixed framerate frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Update&lt;/td&gt;
            &lt;td&gt;Update is called every frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LateUpdate&lt;/td&gt;
            &lt;td&gt;LateUpdate is called every frame, if the Behaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Awake&lt;/td&gt;
            &lt;td&gt;Awake is called when the script instance is being loaded.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnEnable&lt;/td&gt;
            &lt;td&gt;This function is called when the object becomes enabled and active.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDisable&lt;/td&gt;
            &lt;td&gt;This function is called when the behaviour becomes disabled () or inactive.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDestroy&lt;/td&gt;
            &lt;td&gt;This function is called when the MonoBehaviour will be destroyed.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationFocus&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player gets or loses focus.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationPause&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player pauses.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationQuit&lt;/td&gt;
            &lt;td&gt;Sent to all game objects before the application is quit.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Start&lt;/td&gt;
            &lt;td&gt;Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter&lt;/td&gt;
            &lt;td&gt;OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay&lt;/td&gt;
            &lt;td&gt;OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit&lt;/td&gt;
            &lt;td&gt;OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when an incoming collider makes contact with this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where a collider on another object is touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit2D&lt;/td&gt;
            &lt;td&gt;Sent when a collider on another object stops touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter&lt;/td&gt;
            &lt;td&gt;OnTriggerEnter is called when the Collider other enters the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay&lt;/td&gt;
            &lt;td&gt;OnTriggerStay is called once per frame for every Collider other that is touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit&lt;/td&gt;
            &lt;td&gt;OnTriggerExit is called when the Collider other has stopped touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when another object enters a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where another object is within a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit2D&lt;/td&gt;
            &lt;td&gt;Sent when another object leaves a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDown&lt;/td&gt;
            &lt;td&gt;OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseOver&lt;/td&gt;
            &lt;td&gt;OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUp&lt;/td&gt;
            &lt;td&gt;OnMouseUp is called when the user has released the mouse button.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDrag&lt;/td&gt;
            &lt;td&gt;OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseEnter&lt;/td&gt;
            &lt;td&gt;OnMouseEnter is called when the mouse entered the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseExit&lt;/td&gt;
            &lt;td&gt;OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUpAsButton&lt;/td&gt;
            &lt;td&gt;OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渲染相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreCull&lt;/td&gt;
            &lt;td&gt;OnPreCull is called before a camera culls the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameVisible&lt;/td&gt;
            &lt;td&gt;OnBecameVisible is called when the renderer became visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameInvisible&lt;/td&gt;
            &lt;td&gt;OnBecameInvisible is called when the renderer is no longer visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnWillRenderObject&lt;/td&gt;
            &lt;td&gt;OnWillRenderObject is called once for each camera if the object is visible.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreRender&lt;/td&gt;
            &lt;td&gt;OnPreRender is called before a camera starts rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderObject&lt;/td&gt;
            &lt;td&gt;OnRenderObject is called after camera has rendered the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPostRender&lt;/td&gt;
            &lt;td&gt;OnPostRender is called after a camera finished rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderImage&lt;/td&gt;
            &lt;td&gt;OnRenderImage is called after all rendering is complete to render image.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnGUI&lt;/td&gt;
            &lt;td&gt;OnGUI is called for rendering and handling GUI events.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDrawGizmos&lt;/td&gt;
            &lt;td&gt;Implement OnDrawGizmos if you want to draw gizmos that are also pickable and always drawn.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;用图来表示MonoBehavior事件执行顺序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="monobehavior" src="images/monobehaviour_flowchart.svg" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首次加载场景时执行&lt;strong&gt;Awake()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Start()&lt;/strong&gt;只在第一帧才执行, &lt;strong&gt;Start()&lt;/strong&gt;在&lt;strong&gt;Awake()&lt;/strong&gt;之后执行&lt;/li&gt;
&lt;li&gt;Update的执行顺序是: &lt;strong&gt;FixedUpdate()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Update()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;LateUpdate()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以每一帧的&lt;strong&gt;Update()&lt;/strong&gt;事件作分界线：  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Update()之前&lt;/strong&gt;：&lt;strong&gt;物理系统&lt;/strong&gt;和&lt;strong&gt;输入系统&lt;/strong&gt;相关事件先执行，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;和&lt;strong&gt;OnMouseXXX&lt;/strong&gt;事件。此处&lt;strong&gt;XXX&lt;/strong&gt;是占位符，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;可以代表&lt;strong&gt;OnTriggerEnter&lt;/strong&gt;或者&lt;strong&gt;OnTriggerExit&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update()之后&lt;/strong&gt;：&lt;strong&gt;场景渲染&lt;/strong&gt;和&lt;strong&gt;协程&lt;/strong&gt;，如&lt;strong&gt;OnRenderImage()&lt;/strong&gt;和&lt;strong&gt;yield WWW&lt;/strong&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协程中，除了&lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt;是在&lt;strong&gt;FixedUpdate&lt;/strong&gt;之后，&lt;strong&gt;Update&lt;/strong&gt;之前执行，其他的都是在&lt;strong&gt;Update&lt;/strong&gt;之后，&lt;strong&gt;场景渲染&lt;/strong&gt;前执行&lt;/li&gt;
&lt;li&gt;GUI事件&lt;strong&gt;OnGUI&lt;/strong&gt;在场景渲染完之后执行&lt;/li&gt;
&lt;li&gt;当对象被销毁时执行&lt;strong&gt;OnDestory()&lt;/strong&gt;事件&lt;/li&gt;
&lt;li&gt;当游戏退出时执行&lt;strong&gt;OnApplicationQuit()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;和&lt;strong&gt;OnDisable()&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;只有在Object是Active的状态下才能用，一般是Object被初始化或者Object从disable到active过程中被调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnDisable()&lt;/strong&gt;只有到Object从active到disable状态才被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 23 Dec 2014 18:20:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-11-10:yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html</guid><category>Unity3D</category></item><item><title>关于Unity3D编辑器一些事儿</title><link>http://blog.shuiguzi.com/guan-yu-unity3dbian-ji-qi-yi-xie-shi-er.html</link><description>&lt;p&gt;这里描述下Unity3D编辑器使用过程中遇到的坑及其解决方法&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件一：Unity3d编辑器启动时默认打开最近一次打开的项目&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;默认设置中，Unity3D启动时会自动打开默认最近一次打开的项目。每当只想打开小项目，而偏偏上次打开过一个大项目时，这点让人很抓狂。&lt;br /&gt;
&lt;strong&gt;解决方法:&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在编辑器中打开&lt;strong&gt;Unity Preferences&lt;/strong&gt;窗口,通过 &lt;strong&gt;Edit-&amp;gt;Preferences...&lt;/strong&gt;打开&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;General&lt;/strong&gt;选项卡中把&lt;strong&gt;Always Show Project Wizard&lt;/strong&gt;勾选上&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件二：Project Wizard中最近打开项目记录删除不了&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一直不明白为啥不让删除呢？  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法一：让项目地址失效&lt;/strong&gt;  &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;重名名项目文件夹&lt;/li&gt;
&lt;li&gt;把项目移动到别的文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法二：修改注册表&lt;/strong&gt;  &lt;blockquote&gt;
&lt;p&gt;删除 HKEY_CURRENT_USER\Software\Unity Technologies\Unity Editor 4.x 下面以 RecentlyUsedProjectPaths 开头的项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;以后继续补充...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 05 Nov 2014 22:30:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-11-05:guan-yu-unity3dbian-ji-qi-yi-xie-shi-er.html</guid><category>Unity3D</category></item><item><title>ShaderlabVS Release Page</title><link>http://blog.shuiguzi.com/shaderlabvs-release-page.html</link><description>&lt;h2&gt;&lt;em&gt;Latest Version - V0.5&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-28] V0.5 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add braces matching&lt;/li&gt;
&lt;li&gt;Add outlining&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.5/ShaderlabVS-0.5.zip"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1qW9aR5E"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;A introduction of ShaderlabVS can be found at &lt;a href="https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md"&gt;https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md&lt;/a&gt;. If you have feedbacks or questions, send email to me. My email is rockylai@qq.com.&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;&lt;em&gt;Screenshot&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="preview" src="https://github.com/wudixiaop/ShaderlabVS/raw/master/img/Highlighting.PNG" width="100%"/&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;em&gt;History:&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-19] V0.4 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add support for .cginc and .glslinc file&lt;/li&gt;
&lt;li&gt;Add more keywords support&lt;/li&gt;
&lt;li&gt;Syntax highlighting is case insensitive now&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.4/ShaderlabVS.zip"&gt;Github Relase Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1o6sPOUI"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;V0.3 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support Signature help feature&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.3/ShaderlabVS-0.3.zip"&gt;Github Release page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1eQEJQHO"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 28 Oct 2014 21:20:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-10-28:shaderlabvs-release-page.html</guid><category>Shader</category></item><item><title>Why I start ShaderlabVS</title><link>http://blog.shuiguzi.com/why-i-start-shaderlabvs.html</link><description>&lt;p&gt;Last month, &lt;a href="http://unityvs.com/"&gt;SyntaxTree&lt;/a&gt;, the creator of UnityVS plugin for Visual Studio was acquired by Microsoft. Microsoft have published the UnityVS to Visual Studio users for free at the end of July.&lt;/p&gt;
&lt;p&gt;UnityVS is cool tool that make it's possible to debug Unity3D scripts in VS. But the tool is not support the Unity3D shaderlab syntax. it's pain for me to to read/write shader in VS, So I created the ShaderlabVS to help myself and may would help someone who need it.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 19 Oct 2010 18:09:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-08-31:why-i-start-shaderlabvs.html</guid><category>Shader</category></item></channel></rss>