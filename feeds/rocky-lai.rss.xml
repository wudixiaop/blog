<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>心亡则忙，亡心则忘</title><link>http://blog.shuiguzi.com/</link><description>学习、思考、分享</description><atom:link href="http://blog.shuiguzi.com/feeds/rocky-lai.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 23 Sep 2015 16:33:00 +0800</lastBuildDate><item><title>远离 XCodeGhost 影响，各种 XCode 版本下载</title><link>http://blog.shuiguzi.com/yuan-chi-xcodeghost-ying-xiang-ge-chong-xcode-ban-ben-xia-zai.html</link><description>&lt;p&gt;最近 &lt;a href="http://baike.baidu.com/link?url=2582FqWOjsj0CU1shau0JPU--sgJ-moKqnYCcDy87QwZd5jPUwyxiFRbfjmrb8tpZcN8jfSu2Iw-Vokfjn8tJK"&gt;XCodeGhost&lt;/a&gt; 病毒闹的沸沸扬扬,
多款 app 受其影响。就个人觉得之所以会出现这么多从第三方下载 XCode 的情况，可能有如下几个原因引起：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载 XCode 太慢&lt;/li&gt;
&lt;li&gt;需要老版本的 XCode，但是苹果官网找不到 XCode 老版本&lt;/li&gt;
&lt;li&gt;习惯性从网盘等第三方下软件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;速度太慢的问题怎么解决相信网络上有一大推方法，这里就不多说了，下面主要列出 XCode 各个版本的下载地址（&lt;strong&gt;需要 apple id&lt;/strong&gt;）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Xcode 7&lt;ul&gt;
&lt;li&gt;7.1 beta: &lt;a href="https://developer.apple.com/services-account/download?path=/Developer_Tools/Xcode_7.1_beta/Xcode_7.1_beta.dmg"&gt;https://developer.apple.com/services-account/download?path=/Developer_Tools/Xcode_7.1_beta/Xcode_7.1_beta.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;7.0 : &lt;a href="https://developer.apple.com/services-account/download?path=/Developer_Tools/Xcode_7/Xcode_7.dmg"&gt;https://developer.apple.com/services-account/download?path=/Developer_Tools/Xcode_7/Xcode_7.dmg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Xcode 6&lt;ul&gt;
&lt;li&gt;6.4: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.4/Xcode_6.4.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.4/Xcode_6.4.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6.3.2: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3.2/Xcode_6.3.2.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3.2/Xcode_6.3.2.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6.2: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.2/Xcode_6.2.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.2/Xcode_6.2.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6.1.1: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6.1.1/xcode_6.1.1.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6.1.1/xcode_6.1.1.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;6.0.1: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6.0.1/xcode_6.0.1.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_6.0.1/xcode_6.0.1.dmg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Xcode 5&lt;ul&gt;
&lt;li&gt;5.1.1: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_5.1.1/xcode_5.1.1.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_5.1.1/xcode_5.1.1.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;5.0.2: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_5.0.2/xcode_5.0.2.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_5.0.2/xcode_5.0.2.dmg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Xcode 4&lt;ul&gt;
&lt;li&gt;4.6.3: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.6.3/xcode4630916281a.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.6.3/xcode4630916281a.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.5.2: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.5.2/xcode4520418508a.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.5.2/xcode4520418508a.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.4.1: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.4.1/xcode_4.4.1_6938145.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.4.1/xcode_4.4.1_6938145.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.3.2: &lt;a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.3.2/xcode_432_lion.dmg"&gt;https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.3.2/xcode_432_lion.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.2: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.2_for_lion_21264/installxcode_42_lion.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.2_for_lion_21264/installxcode_42_lion.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.1: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.1_for_lion_21263/installxcode_41_lion.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.1_for_lion_21263/installxcode_41_lion.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;4.0.2: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.0.2_and_ios_sdk_4.3/xcode_4.0.2_and_ios_sdk_4.3.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_4.0.2_and_ios_sdk_4.3/xcode_4.0.2_and_ios_sdk_4.3.dmg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他更老版本&lt;ul&gt;
&lt;li&gt;3.2.6: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.2.6_and_ios_sdk_4.3__final/xcode_3.2.6_and_ios_sdk_4.3.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.2.6_and_ios_sdk_4.3__final/xcode_3.2.6_and_ios_sdk_4.3.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3.1.4: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.1.4_developer_tools/xcode314_2809_developerdvd.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.1.4_developer_tools/xcode314_2809_developerdvd.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3.0: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.0/xcode_3.0.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_3.0/xcode_3.0.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.5: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.5_developer_tools/xcode25_8m2558_developerdvd.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.5_developer_tools/xcode25_8m2558_developerdvd.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.4.1: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.4.1/xcode_2.4.1_8m1910_6936315.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.4.1/xcode_2.4.1_8m1910_6936315.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.3: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.3/xcode_2.3_8m1780_oz693620813.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_2.3/xcode_2.3_8m1780_oz693620813.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.2.1: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_tools_2.2.1/xcode_2.2.1_8g1165_018213632.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_tools_2.2.1/xcode_2.2.1_8g1165_018213632.dmg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.5: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_v1.5/xcode_tools_1.5_cd.dmg.bin"&gt;http://developer.apple.com/devcenter/download.action?path=/Developer_Tools/xcode_v1.5/xcode_tools_1.5_cd.dmg.bin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;1.0: &lt;a href="http://developer.apple.com/devcenter/download.action?path=/Mac_OS_X/Mac_OS_X_10.3_Build_7B85/7B85_Xcode_CD.dmg"&gt;http://developer.apple.com/devcenter/download.action?path=/Mac_OS_X/Mac_OS_X_10.3_Build_7B85/7B85_Xcode_CD.dmg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载地址来源于 &lt;a href="http://stackoverflow.com/questions/10335747/how-to-download-xcode-4-5-6-7-and-get-the-dmg-file"&gt;http://stackoverflow.com/questions/10335747/how-to-download-xcode-4-5-6-7-and-get-the-dmg-file&lt;/a&gt;。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 23 Sep 2015 16:33:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-09-23:yuan-chi-xcodeghost-ying-xiang-ge-chong-xcode-ban-ben-xia-zai.html</guid><category>Unity</category></item><item><title>如何改变图片亮度</title><link>http://blog.shuiguzi.com/ru-he-gai-bian-tu-pian-liang-du.html</link><description>&lt;p&gt;有的时候我们有可能有需求将较暗的图像简单的提亮，这篇文章主要讲一种改变图片亮度的方式。我们从两个问题入手：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了提亮图片，我们操作的对象是什么？&lt;/li&gt;
&lt;li&gt;怎么操作对象能达到改变亮度的效果？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Unity 中的 Color&lt;/h3&gt;
&lt;p&gt;首先我们来回答第一个问题。聪明的你可能已经知道，我们要操作的对象是 &lt;strong&gt;像素&lt;/strong&gt; 。Unity 中 Color 
类的一个实例能表示一个像素点。&lt;/p&gt;
&lt;p&gt;Color 类有 4 个字段表示颜色的各通道数值，他们分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 红色通道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 绿色通道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 蓝色通道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; aplha通道&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各个通道的数值都是被标准化为 &lt;code&gt;0...1&lt;/code&gt; 之间的值。&lt;/p&gt;
&lt;h3&gt;改变亮度的算法&lt;/h3&gt;
&lt;p&gt;上面 Color 各通道的数值都被标准化，这里我们也依葫芦画瓢来把我们要提高的亮度 brightness 一个数值，不过我们设定它的取值区间为
&lt;code&gt;-1...1&lt;/code&gt;。当 brightness 为负数的时候，图片减暗，正数时，图片变亮。&lt;/p&gt;
&lt;p&gt;算法, 假设 RGB 通道值为 c：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 brightness &amp;lt; 0 时 c = c + c * brightness&lt;/li&gt;
&lt;li&gt;当 brightness &amp;gt;= 0 时 c = c + c * ( 1 / (1 - brightness) - 1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;代码实现：&lt;/h3&gt;
&lt;p&gt;结合上面两个点，我们可以写出类似下面示例代码实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;BrightenScript&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;RangeAttribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Texture2D&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Brighten&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;GetComponent&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Renderer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;material&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mainTexture&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Brighten&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Texture2D&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;colors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPixels&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;// 对 RGB 通道都做处理&lt;/span&gt;
        &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BrightenChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BrightenChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BrightenChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetPixels&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;colors&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Apply&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="nf"&gt;BrightenChannel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;brightness&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;brightness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;brightness 为 0.6 时效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="0.6" src="images/BrigthenImage/b1.png" width="24%" /&gt; &lt;/p&gt;
&lt;p&gt;brightness 为 -0.5 时效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="-0.5" src="images/BrigthenImage/b2.png" width="24%" /&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 15 Sep 2015 22:28:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-09-15:ru-he-gai-bian-tu-pian-liang-du.html</guid><category>Unity</category><category>Graphic</category></item><item><title>UNet 0x06: Command</title><link>http://blog.shuiguzi.com/unet-0x06-command.html</link><description>&lt;p&gt;最开始我们来对上篇文章 &lt;a href="http://blog.shuiguzi.com/unet-0x05-syncvar.html"&gt;UNet 0x05: SyncVar&lt;/a&gt; 中的程序做点修改。在这里也建议朋友们先阅读上篇，然后继续阅读下面内容。&lt;/p&gt;
&lt;p&gt;我们先把只在 Server 端绘制的按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isServer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ChangeState&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改成在 Client 端绘制&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isServer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 这里是改变的地方&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ChangeState&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改完之后我们运行程序会得到一个结果：无论我们怎么点 ChangeState 按钮，Client 端左上角文字有变化，而 Server 端左上角的文字都不会变化。&lt;/p&gt;
&lt;p&gt;这为什么呢？我们上篇文章中提到 SyncVar 只能从 Server 到 Client 端的方向起作用，所以我们上面点击 ChangeState 按钮
是在 Client 端执行的，只改变了 Client 端的值，不会对 Server 端起作用。&lt;/p&gt;
&lt;p&gt;这篇要介绍的就是能从 Client 端做出的改变也能同步的所有终端的功能。它就是 NetworkBevhaiour 提供 &lt;strong&gt;sending commands&lt;/strong&gt; 功能。&lt;/p&gt;
&lt;h3&gt;Command&lt;/h3&gt;
&lt;p&gt;那什么是 Command 呢？如果了解设计模式的朋友应该知道有种设计模式叫做 Command 模式（命令模式），这里的 Command 代表一种行为，
UNet 中的 Command 也是代表一种行为，换句话说就是一个函数。但是在 UNet 中这个函数有些特别的规定，它要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数的名字 &lt;strong&gt;必须以 Cmd 开头&lt;/strong&gt;，这里注意大小写哟。&lt;/li&gt;
&lt;li&gt;必须带上 &lt;strong&gt;[Command]&lt;/strong&gt; 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用代码来示范下就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;CmdDoSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// do something&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里还有几点需要知道的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command 是从 Client 端发起的。当需要从 Client 端发出改变的时候使用它。&lt;/li&gt;
&lt;li&gt;每个客户端的 spawn 之后的对象，都会在其他各端（包括 Server）有同样的实例。而真实执行 Command 的是在 Server 上
的那个实例。所以其实 Command 的执行最终也是在 Server 上的，只不过 Client 会发送请求，要求 Server 上对应的实例来
执行这个 Command。这正好符合 UNet 是以 Server 为主导的理念。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们继续对上篇文章中的代码做些修改。&lt;/p&gt;
&lt;p&gt;首先，我们新加入一个 Command 方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;CmdChangeState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后我们把 ChangeState 调用的方法从 &lt;code&gt;ChangeState()&lt;/code&gt; 改成 &lt;code&gt;CmdChangeState()&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGUI&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isServer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ChangeState&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;CmdChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样我们就利用了 Command 方法 &lt;code&gt;CmdChangeState&lt;/code&gt; 来作出改变了。&lt;/p&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;下面是加上 Command 方法之后的最终代码。这样每次在 Client 端点击 ChangeState 按钮的时候，各个终端中 State 字段的值都会发生改变。
Demo 程序的地址为: &lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/106%20-%20Command"&gt;https://github.com/wudixiaop/UNet/tree/master/Assets/106%20-%20Command&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;CommandSample&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NetworkBehaviour&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SyncVar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Init State&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MaxValue&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Command&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;CmdChangeState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;OnGUI&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isServer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ChangeState&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//  ChangeState();&lt;/span&gt;
            &lt;span class="n"&gt;CmdChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}&lt;/p&gt;
&lt;h3&gt;SyncVar Vs Command&lt;/h3&gt;
&lt;p&gt;下面是一张从 Unity 手册中借来的一种图片，&lt;/p&gt;
&lt;p&gt;&lt;img alt="UNetDirection" src="images/UNet/UNetDirections.jpg" width="46%" /&gt;&lt;/p&gt;
&lt;p&gt;上面图中的 &lt;code&gt;State Updates&lt;/code&gt; 是指的 SyncVar。我们从图中可以了解到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SyncVar 是从 Server -&amp;gt; Client 方向来改变所有端的同一对象实例的状态&lt;/li&gt;
&lt;li&gt;Command 是从 Client -&amp;gt; Server 方向来改变所有端的同一对象实例的状态&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 13 Aug 2015 14:53:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-23:unet-0x06-command.html</guid><category>UNet</category><category>Unity</category></item><item><title>UNet 0x05: SyncVar</title><link>http://blog.shuiguzi.com/unet-0x05-syncvar.html</link><description>&lt;p&gt;开篇需要先介绍一个 UNet 系统里面提供的一个类，名字叫做 &lt;strong&gt;NetworkBehaviour&lt;/strong&gt;。看到名字，不禁让人想起
 MonoBehaviour。NetworkBehaviour 继承自 MonoBehaviour，所以基于 NetworkBehaviour 的脚本也是能挂在 
 GameObject 上面的。&lt;/p&gt;
&lt;p&gt;NetworkBehaviour 给我们提供了什么功能呢？大概是如下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Synchronized Variables&lt;/li&gt;
&lt;li&gt;Network callbacks&lt;/li&gt;
&lt;li&gt;Server and Client functions&lt;/li&gt;
&lt;li&gt;Sending Commands&lt;/li&gt;
&lt;li&gt;Client RPC Calls&lt;/li&gt;
&lt;li&gt;Networked Events&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了让描述更准确，上面采用了 &lt;a href="http://docs.unity3d.com/Manual/class-NetworkBehaviour.html"&gt;官方手册&lt;/a&gt; 
中的英文描述。这篇的主角就是 Synchronized Variables。&lt;/p&gt;
&lt;h3&gt;SyncVar 初见&lt;/h3&gt;
&lt;p&gt;我们在接下来把 Synchronized Variables 简称为 SyncVar 。我们先给它来下个粗略的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它是 NetworkBehaviour 的一个带有 [SyncVar] 属性的字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意定义中 &lt;strong&gt;SyncVar 是字段，不是属性&lt;/strong&gt;。示意代码大概是这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SpaceShip&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NetworkBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SyncVar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;health&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SyncVar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;playerName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中带有两个 SyncVar。&lt;/p&gt;
&lt;p&gt;当 SyncVar 发生改变时，UNet 会从 Server 端向所有有效的 Client 端发送这些改变。注意这里的方向，是从 Server 
到 Client ，而不是从 Client 到 Server 的方向。&lt;/p&gt;
&lt;h3&gt;SyncVar 数据类型&lt;/h3&gt;
&lt;p&gt;既然 SyncVar 是字段，字段是有数据类型的。UNet 中这样规定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以是&lt;/strong&gt; 所有基本数据类型，比如 string，int，float，bool 等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以是&lt;/strong&gt; 结构数据，比如 Vector3 等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可以是&lt;/strong&gt; 类、列表、集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概就是 &lt;strong&gt;值类型可以，引用类型不可以&lt;/strong&gt;。当然大部分情况下是这样，特殊情况是存在的。除了 &lt;code&gt;String&lt;/code&gt; 这个特殊的
引用类型除外，下面会介绍。&lt;/p&gt;
&lt;p&gt;那就是疑问了，既然不能是列表和集合，那如果真要同步一组数组怎么办？&lt;/p&gt;
&lt;p&gt;UNet 提供了一些特殊的类，称之为 SyncList, 这些类是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SyncListString&lt;/li&gt;
&lt;li&gt;SyncListFloat&lt;/li&gt;
&lt;li&gt;SyncListInt&lt;/li&gt;
&lt;li&gt;SyncListUInt&lt;/li&gt;
&lt;li&gt;SyncListBool &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们都继承自 &lt;code&gt;SyncList&amp;lt;T&amp;gt;&lt;/code&gt; 泛型类。当然内建类型有局限性，不能满足所有需求，所以 UNet 还给我们提供
了 &lt;code&gt;SyncListStruct&amp;lt;T&amp;gt;&lt;/code&gt; 泛型类，我们可以通过定义它的子类来扩展，从而达到我们的需求。下面是一个 &lt;code&gt;SyncListStruct&amp;lt;T&amp;gt;&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;MyScript&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NetworkBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;POW&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SyncListPOW&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SyncListStruct&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;POW&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;SyncListPOW&lt;/span&gt; &lt;span class="n"&gt;m_pows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SyncListPOW&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意到没有？上面的 &lt;strong&gt;m_pows&lt;/strong&gt; 字段并没有 [SyncVar] 属性。这里有一点非常重要，&lt;strong&gt;SyncList 类型
的字段，不需要带上 [SyncVar] 属性&lt;/strong&gt;。这下子，上面给出的定义要改改了。&lt;/p&gt;
&lt;h3&gt;SyncVar 定义&lt;/h3&gt;
&lt;p&gt;让我们来重新给 SyncVar 下定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;它是 NetworkBehaviour 中的一个字段， 如果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它的类型是基本类型或结构，则需要带上 [SyncVar] 属性&lt;/li&gt;
&lt;li&gt;它的类型继承自 SyncList&lt;T&gt; 或者 SyncListStruct&lt;T&gt;，则不需要带上 [SyncVar] 属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;Demo 可以再这里找到：&lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/105%20-%20Sync%20Var"&gt;https://github.com/wudixiaop/UNet/tree/master/Assets/105%20-%20Sync%20Var&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SyncVar 相关代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SyncVarSample&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NetworkBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SyncVar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Init State&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MaxValue&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGUI&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Label&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;// 因为 UNet 是以 Server 为主导的系统，只有在 Server 端改变值才能起作用&lt;/span&gt;
        &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isServer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ChangeState&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;ChangeState&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要将上面脚本挂到 Spawn Prefab 上面（Spawn Prefab详细参照&lt;a href="http://blog.shuiguzi.com/unet-0x04-zuo-yi-ge-jian-dan-de-network-manager-jie-mian.html"&gt;上一篇文章&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;将 Demo 程序 build 之后，单独运行 build 出来的程序，并启动 Server。在 Unity 编辑器中运行程序，连接 Server。
我们会得到如下截图的样子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="syncvaroutput" src="images/UNet/syncvarOutput.jpg" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;我们每次点击 ChangeState 按钮，左上角的数字就会发生变化。Server 改变了 State 字段的值，Client 端也对应发生改变。&lt;/p&gt;
&lt;p&gt;这篇就到这里。Enjoy!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Sat, 15 Aug 2015 14:53:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-15:unet-0x05-syncvar.html</guid><category>UNet</category><category>Unity</category></item><item><title>UNet 0x04: 做一个简单的 Network Manager 界面</title><link>http://blog.shuiguzi.com/unet-0x04-zuo-yi-ge-jian-dan-de-network-manager-jie-mian.html</link><description>&lt;p&gt;上一篇中我们引入了 NetworkManager 组件，然后在代码里面通过它来建立了网络连接。这篇让我们来把连接部分的代码独立出来，并提供 GUI 来达到管理 Server / Client 的开启和停止的目的。
这样我们以后就可以重复利用代码了。&lt;/p&gt;
&lt;p&gt;下面是我们这个简单的 NetworkManger 界面提供的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以启动 / 停止 Server，并且多个程序端只能启动一个 Server&lt;/li&gt;
&lt;li&gt;可以启动 / 停止 Client 并连接 Server&lt;/li&gt;
&lt;li&gt;当 Server 停止时，所有 Client 端界面都会重置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个简单的界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ui" src="images/UNet/SimpleUI.PNG" /&gt;&lt;/p&gt;
&lt;p&gt;本篇中的 demo 可以 &lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/104%20-%20simple%20network%20GUI"&gt;戳这里&lt;/a&gt; 得到，下面就 Demo 细说一下。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;我们通过 NetworkManager 的 &lt;code&gt;StartServer()&lt;/code&gt; / &lt;code&gt;StopServer()&lt;/code&gt; 方法来开启 / 停止 Server, &lt;code&gt;StartClient()&lt;/code&gt; / &lt;code&gt;StopClient()&lt;/code&gt; 方法来启动 / 停止 Client。我们可以新建一个 GameObject，
然后把下面脚本挂在它上面。脚本代码如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SimpleNetworkGUI&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnDisconnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;Application&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;LoadLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Application&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadedLevel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnGUI&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Stop&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StopServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StopClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                &lt;span class="n"&gt;OnDisconnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;2f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Start Server&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GUI&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;2f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Screen&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Start Client&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Disconnect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnDisconnected&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;isHaveNetworkRole&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关于 Demo 其他一些需要知道的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先，代码中利用了 NetworkManager 组件。我们可以把这个组件挂到挂有上面 UI 脚本的 GameObject 之上。&lt;/li&gt;
&lt;li&gt;为了演示效果，Demo 里面创建了一个Prefab， 这个 Prefab 会传递给上面的 NetworkManager 组件（Spawn Info 下的 Player Prefab）。当 Client 连接已经启动的 Server 的时候，Server 端会创建这个 Perfab 的实例。
这个 Prefab 比较特殊，它上面需要添加 &lt;strong&gt;NetworkIndentity&lt;/strong&gt; 组件，这样才能传递过去给 NetworkManager。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到这里，可能有的朋友有疑问。什么 Spawn？ NetworkIndentity 又是什么鬼？&lt;/p&gt;
&lt;h3&gt;UNet 中的 Spawn&lt;/h3&gt;
&lt;p&gt;换句话说，Spawn 就是网络对象实例的初始化这个行为，再换句话说就是创建网络对象。在 UNet 中用 Spawn 来描述，而不是用 Instantiate。&lt;/p&gt;
&lt;p&gt;UNet 是个以 Server 为主导的系统，所有的 Spawn 行为都要在 Server 端发生，通过调用 &lt;code&gt;NetworkServer.Spawn( GameObject go )&lt;/code&gt; 方法，产生的对象会在各个 Client 出现对应的实例。&lt;/p&gt;
&lt;h3&gt;网络对象与 NetworkIndentity&lt;/h3&gt;
&lt;p&gt;每个网络对象（Networked Object）都需要在根上带上 NetworkIndentity 组件。那 NetworkIndentity 组件是什么？ 大概是这个样子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是标志对象网络身份的一个组件&lt;/li&gt;
&lt;li&gt;拥有系统用来跟踪对象的信息，比如 SenceId, NetworkID, AssetID 等&lt;/li&gt;
&lt;li&gt;所有需要 Spawn 的 Prefab 都必须在对象根上带有这个组件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对了，需要注意一点。带有 NetworkIndentity 组件的对象，在未 Spawn 之前是不可用的，Disabled 状态，即使在 Hierarchy 里面有它的实例也会自动被 Disabled.&lt;/p&gt;
&lt;h3&gt;NetworkManagerHUD 组件&lt;/h3&gt;
&lt;p&gt;为什么要提到这个组件呢。因为它也是一个 NetworkManager 管理的界面。它是 Unity 提供给我们的，提供比我们这篇文章所给的更加丰富的功能。平时开发调试的时候，建议使用这个控件。
引出 NetworkManagerHUD 组件也是这篇文章的目的。&lt;/p&gt;
&lt;p&gt;好了，这篇就到这里。Enjoy!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 12 Aug 2015 14:53:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-12:unet-0x04-zuo-yi-ge-jian-dan-de-network-manager-jie-mian.html</guid><category>UNet</category><category>Unity</category></item><item><title>UNet 0x03: NetworkManager 初见</title><link>http://blog.shuiguzi.com/unet-0x03-networkmanager-chu-jian.html</link><description>&lt;p&gt;阅读本章之前, 建议先阅读 &lt;a href="http://blog.shuiguzi.com/unet-0x01-wang-luo-lian-jie-de-jian-li.html"&gt;UNet 0x01: 网络连接的建立&lt;/a&gt; 和 &lt;a href="http://blog.shuiguzi.com/unet-0x02-fa-song-xiao-xi.html"&gt;UNet 0x02: 发送消息&lt;/a&gt; 这两篇文章。&lt;/p&gt;
&lt;p&gt;前两篇文章我们建立 Client / Server 间的连接的时候，手动配置了 Server 的端口和 Client 要连接的目标 Server 及其端口。这些都是在代码里面实现
的。这篇文章我们引入 UNet 提供的一个网络管理组件来达到同样的效果。这个组件的名字叫做 NetworkManager。&lt;/p&gt;
&lt;p&gt;NetworkManager 组件提供了很多功能，但是这篇文章只引入 NetworkManager 组件，不打算深入讲这个组件。下面是 NetworkManager 在 Inspector 里面的长相：&lt;/p&gt;
&lt;p&gt;&lt;img alt="networkmanager" src="images/UNet/NetworkManagerInspector.PNG" width="46.2%" /&gt;&lt;/p&gt;
&lt;p&gt;上图中 Network Info 部分就是就是配置 Server 地址及其端口的地方。&lt;/p&gt;
&lt;p&gt;接下来看看 NetworkManager 如何启动一个 Server / Client / Host。&lt;/p&gt;
&lt;h3&gt;利用 NetowrkManager 的方法替换之前代码&lt;/h3&gt;
&lt;p&gt;利用 NetworkManager 的方法替换之前的代码，大体为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;之前我们用 &lt;code&gt;NetworkServer.listen(port)&lt;/code&gt; 来启动一个 Server 并监听某个端口。NetworkManager 提供 &lt;code&gt;StartServer()&lt;/code&gt; 方法替代&lt;/li&gt;
&lt;li&gt;之前我们单独创建了 NetowrkClint 类的实例开创建 Client。 NetworkManager 提供 &lt;code&gt;StartClient()&lt;/code&gt; 方法替代&lt;/li&gt;
&lt;li&gt;如果想启动 Host (Server + Local Client)，NetworkManager 提供 &lt;code&gt;StartHost()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;得到 NetworkManager 实例&lt;/h3&gt;
&lt;p&gt;NetworkManager 组件挂上 GameObject 之后我们可以像其他组件一同通过 &lt;code&gt;GetComponent&amp;lt;T&amp;gt;()&lt;/code&gt; 这个方法来得到其实例，但是这推荐使用 &lt;code&gt;NetworkManager.singleton&lt;/code&gt; 
来得到其实例。&lt;/p&gt;
&lt;h3&gt;为什么要使用 NetworkManager&lt;/h3&gt;
&lt;p&gt;我觉得大概有如下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NetworkManager 包装了很多信息的设置，提供统一的入口&lt;/li&gt;
&lt;li&gt;利用现成 NetworkManager 提供的功能，简化代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但总体上的目的还是简化，复用代码。&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;下面代码和 &lt;a href="http://blog.shuiguzi.com/unet-0x02-fa-song-xiao-xi.html"&gt;UNet 0x02: 发送消息&lt;/a&gt; 一样，也是发送消息。功能上的区别就是下面代码中 Client 会每隔 5 秒自动发送消息给 Server。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;ComBaseOnNetworkManager&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;interval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;5f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SetupServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;SetupClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;interval&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;interval&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;SendMessageToServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetupServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;active&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnMessageReceived&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetupClient&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NetworkManager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;singleton&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StartClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnMessageReceived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SERVER: {0}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadMessage&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SendMessageToServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MessageX&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;From&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;NetworkMangerBase Sample&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello Rocky!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码可以在这里找到：&lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/103%20-%20introduce%20NetworkManager"&gt;Github 地址&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;新建一个 GameObject， 在它挂上上面的脚本，然后添加 NetworkManager 组件，然后运行项目。控制台会得到类似下面的输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="output" src="images/UNet/103Output.PNG" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 10 Aug 2015 16:05:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-10:unet-0x03-networkmanager-chu-jian.html</guid><category>UNet</category><category>Unity</category></item><item><title>UNet 0x02: 发送消息</title><link>http://blog.shuiguzi.com/unet-0x02-fa-song-xiao-xi.html</link><description>&lt;p&gt;&lt;a href="http://blog.shuiguzi.com/unet-0x01-wang-luo-lian-jie-de-jian-li.html"&gt;上一篇文章&lt;/a&gt; 中介绍了如何在 UNet 中建立网络连接，接下来我们在这篇文章中说说建立连接之后怎么在 Client / Server 间发送消息。&lt;/p&gt;
&lt;p&gt;这篇文章涉及的是 UNet HLAPI 部分消息发送所涉及到一些概念，最后会给出一个示例代码。按之前的风格，我们继续来抱着问题讲述今天的主题。&lt;/p&gt;
&lt;p&gt;有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UNet HLAPI 中消息怎么表示？&lt;/li&gt;
&lt;li&gt;UNet HLAPI 中消息怎么发送和接收？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;UNet HLAPI 中的消息&lt;/h3&gt;
&lt;p&gt;新的网路系统 UNet 提供了一个抽象类，叫做 &lt;code&gt;MessageBase&lt;/code&gt;, 它的原型大概是下面这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MessageBase&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// De-serialize the contents of the reader into this message&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Deserialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkReader&lt;/span&gt; &lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="c1"&gt;// Serialize the contents of this message into the writer&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Serialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkWriter&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;MessageBase&lt;/code&gt; 提供了系列化/反序列化的功能，我们 &lt;strong&gt;需要通过继承这个类来自定义消息&lt;/strong&gt; 。所以一般情况下 UNet HLAPI 中的消息都是 &lt;code&gt;MessageBase&lt;/code&gt; 的子类。&lt;/p&gt;
&lt;p&gt;UNet 在 &lt;code&gt;UnityEngine.Networking.NetworkSystem&lt;/code&gt; 命名空间中提供了一些内建的类供我们使用，例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EmptyMessage&lt;/li&gt;
&lt;li&gt;StringMessage&lt;/li&gt;
&lt;li&gt;IntegerMessage&lt;/li&gt;
&lt;li&gt;ErrorMessage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然我们也可以不适用内建的类，自己自定义新消息类。比如我们定义一个（我单纯的自认为）高大上的名字的类，叫做 &lt;code&gt;MessageX&lt;/code&gt;，继承自 &lt;code&gt;MessageBase&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Customize message and Type&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;MessageX&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MessageBase&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;readonly&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;MsgType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MaxValue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// Use Field here, NOT Property&lt;/span&gt;
    &lt;span class="c1"&gt;//&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;From&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;override&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nf"&gt;ToString&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Message &amp;#39;{0}&amp;#39; from &amp;#39;{1}&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;From&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里要说一下一个自定义消息类型的坑：&lt;strong&gt;要使用字段来代替属性&lt;/strong&gt;，如果使用了属性会导致接受不到发送的消息数据。&lt;/p&gt;
&lt;p&gt;错误的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;MessageX&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MessageBase&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;MessageX&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MessageBase&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;Message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个坑请注意下，以防掉入~~  &lt;/p&gt;
&lt;h3&gt;发送消息的 API&lt;/h3&gt;
&lt;p&gt;上小节，我们有了 &lt;code&gt;MessageX&lt;/code&gt; 这个高大上名字的消息，我们怎么发出去，然后怎么接受呢？&lt;/p&gt;
&lt;p&gt;先说发送。UNet 中下面几个方法都可以发送:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NetworkClient.Send( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkConnection.Send( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendToAll( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendToReady( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendToClient( int connectionId, short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendUnreliableToAll( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendUnreliableToReady( short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkServer.SendToClientOfPlayer( GameObject player, short msgType, MessageBase msg)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各个方法用各自的用途，具体可以参照 &lt;a href="http://docs.unity3d.com/ScriptReference/Networking.NetworkClient.html"&gt;NetworkClient&lt;/a&gt;、
&lt;a href="http://docs.unity3d.com/ScriptReference/Networking.NetworkConnection.html"&gt;NetworkConnection&lt;/a&gt; 和 
&lt;a href="http://docs.unity3d.com/ScriptReference/Networking.NetworkServer.html"&gt;NetworkServer&lt;/a&gt; 官方 API 文档。&lt;/p&gt;
&lt;p&gt;本文章中将使用 &lt;code&gt;NetworkClient.Send(short msgType, MessageBase msg)&lt;/code&gt; 方法，在 Client 端给 Server 端发送消息。发送的代码示意：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;messageInput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;From&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fromInput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;Send&lt;/code&gt; 方法中第二个参数是消息的实例，这个很明显，不需要特别解释。那第一个参数 msgType 又是什么的？ 看过上一篇文章 &lt;a href="http://blog.shuiguzi.com/unet-0x01-wang-luo-lian-jie-de-jian-li.html"&gt;UNet 0x01: 网络连接的建立&lt;/a&gt;
的朋友们可能马上就想起来在 &lt;strong&gt;事件注册 RegisterHandler&lt;/strong&gt; 小节中也有 msgType。对的，就是这个。消息接收就是通过事件注册的方式来处理。接收的示意代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 注册消息处理事件&lt;/span&gt;
&lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnMessageXReceived&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnMessageXReceived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageX&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadMessage&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SERVER: {0}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面使用到了 &lt;code&gt;NetworkMessage.ReadMessage&amp;lt;T&amp;gt;()&lt;/code&gt; 方法来得到发送过来的 &lt;code&gt;MessageX&lt;/code&gt; 类型的消息。&lt;/p&gt;
&lt;h3&gt;将所有串联起来的示例&lt;/h3&gt;
&lt;p&gt;我们创建一个简单的 UI 如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="UI" src="images/UNet/sendMessageUI.PNG" width="72%" /&gt;&lt;/p&gt;
&lt;p&gt;我们创建一个 &lt;code&gt;SendMessageX&lt;/code&gt; 类用来接收 UI 输入的文字，然后发送给 Server, 用 &lt;code&gt;Debug.log()&lt;/code&gt; 输出到控制台窗口。&lt;code&gt;SendMessageX&lt;/code&gt; 类的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SendMessageX&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;serverPort&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4444&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputField&lt;/span&gt; &lt;span class="n"&gt;messageInput&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputField&lt;/span&gt; &lt;span class="n"&gt;fromInput&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;SetupServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;SetupClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cp"&gt;#region Server&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetupServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;active&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnMessageXReceived&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serverPort&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;success&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Server Started&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Start Server failed&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A client connected!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnMessageXReceived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MessageX&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ReadMessage&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SERVER: {0}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cp"&gt;#endregion&lt;/span&gt;

    &lt;span class="cp"&gt;#region Client&lt;/span&gt;

    &lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetupClient&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NetworkClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;serverPort&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SendMesssageXToServer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MessageX&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;messageInput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;From&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fromInput&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MessageX&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CLIENT: {0}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mx&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cp"&gt;#endregion&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果将 &lt;code&gt;Remote Client&lt;/code&gt; 输入到 &lt;strong&gt;From&lt;/strong&gt;、&lt;code&gt;Hello World&lt;/code&gt; 输入到 &lt;strong&gt;Message&lt;/strong&gt; 输入框之后，点击 &lt;strong&gt;Send Message&lt;/strong&gt; 按钮，我们得到如下输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="sendMessageOutput" src="images/UNet/sendMessageOutput.PNG" width="88%" /&gt;&lt;/p&gt;
&lt;p&gt;所有代码可以在这里找到：&lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/102%20-%20send%20message"&gt;https://github.com/wudixiaop/UNet/tree/master/Assets/102%20-%20send%20message&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Fri, 07 Aug 2015 16:05:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-07:unet-0x02-fa-song-xiao-xi.html</guid><category>UNet</category><category>Unity</category></item><item><title>UNet 0x01: 网络连接的建立</title><link>http://blog.shuiguzi.com/unet-0x01-wang-luo-lian-jie-de-jian-li.html</link><description>&lt;p&gt;看到标题后，没接触过的朋友脑中可能会闪现出这样一个问题： UNet 是什么 ? 其实它是 Unity 5.1 版本新引入的网络系统。官方论坛里面称这个系统为 UNet, 那我们按照官方的习惯来。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.unity3d.com/Manual/UNetOverview.html"&gt;官方手册文档&lt;/a&gt; 介绍其主要有两类功能（按 API 抽象层次来分）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低层次 &lt;a href="http://docs.unity3d.com/Manual/UNetUsingTransport.html"&gt;NetworkTransport API&lt;/a&gt;， 适合于用来构建更复杂高级的多人游戏或者网络基础平台&lt;/li&gt;
&lt;li&gt;高层次的 High Level API，也叫做 HLAPI，建立在 NetworkTransport 之上。适合开发多人游戏&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章将只涉及 High Level API。我们的目的是建立（Client 于 Server 间的）网络连接。&lt;/p&gt;
&lt;h3&gt;UNet 的 Server / Client / Host&lt;/h3&gt;
&lt;p&gt;在 UNet 先系统中会出现 1 个 Server 和 n 个 Client (n &amp;gt;= 0)。当没有专门的 Server 的时候，其中一个 Client 会充当 Server 的作用，这个即是 Client 又是 Server 的端在 UNet 中
被称为 Host。 Host 在同一个进程里面执行 Server 和 Client, 这个 Client　有个专门的名字叫做 Local Client。它跟 Local Server 之间是通过 &lt;strong&gt;消息队列&lt;/strong&gt; 和 &lt;strong&gt;直接的函数调&lt;/strong&gt; 用来通信的。 &lt;/p&gt;
&lt;p&gt;Unity3d 网站上有张图能比较明显的表达 Server / Client / Local Client / Host 直接的关系，让我们把它偷过来。:)&lt;/p&gt;
&lt;p&gt;&lt;img alt="NetworkHost" src="images/UNet/NetworkHost.png" width="78%" /&gt;&lt;/p&gt;
&lt;h3&gt;Server 创建&lt;/h3&gt;
&lt;p&gt;Unity 给我们提供了 &lt;a href="http://docs.unity3d.com/ScriptReference/Networking.NetworkServer.html"&gt;NetworkServer&lt;/a&gt; 类，他的静态方法 &lt;code&gt;Listen(int serverPort)&lt;/code&gt; 会打开一个端口监听。&lt;/p&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenPort&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Client 创建&lt;/h3&gt;
&lt;p&gt;从前面的途中我们知道有 Local Client 和 Remote Client 之分，他们的创建方法也是不一样的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local Client：使用 &lt;code&gt;ClientScene.ConnectLocalServer()&lt;/code&gt; 静态方法创建&lt;/li&gt;
&lt;li&gt;Remote Client：Unity 给我们提供过了 &lt;a href="http://docs.unity3d.com/ScriptReference/Networking.NetworkClient.html"&gt;NetworkClient&lt;/a&gt; 类来创建。类的实例就是 Remote Client。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Remote Client&lt;/span&gt;
&lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NetworkClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Local Client&lt;/span&gt;
&lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ClientScene&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConnectLocalServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;事件注册 RegisterHandler&lt;/h3&gt;
&lt;p&gt;其实现在添加这节内容处在只是为了接下来代码答应的调试信息。NetworkServer 和 NetworkClient 类都有 &lt;code&gt;RegisterHandler(short msgType, Networking.NetworkMessageDelegate handler);&lt;/code&gt; 
方法，这个方法用来来注册对应消息的处理函数。它有两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个参数 msgType 是个 short 类型，Unity 提供 &lt;a href="http://docs.unity3d.com/ScriptReference/Networking.MsgType.html"&gt;MsgType&lt;/a&gt; 类来得到所有内置的数值。
当然我们也可以自定义数值哦~~&lt;/li&gt;
&lt;li&gt;第二个参数 handler 是 NetworkMessageDelegate 类型，类型的原型是 &lt;strong&gt;delegate void NetworkMessageDelegate( Networking.NetworkMessage netMsg )&lt;/strong&gt;。
这是 C# 中的 delegate, 我们要提供的消息响应函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本节例子中，我们在 Server 和 Client 端都注册 &lt;code&gt;MsgType.Connect&lt;/code&gt; 消息，然后其响应函数为 &lt;code&gt;OnConnected(NetworkMessage msg)&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Do someting&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;对了，在提供 sample 代码之前，需要说明一下，UNet 的类和其他类型都在 &lt;code&gt;UnityEngine.Networking&lt;/code&gt; 这个命名空间之下。&lt;/p&gt;
&lt;p&gt;Server 端的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SetupServer&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;listenPort&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4444&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ServerSetup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ServerSetup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listenPort&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;NetworkServer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Server: connection happen&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Client 端的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;UnityEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Networking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="nl"&gt;SetupClient&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;MonoBehaviour&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;127.0.0.1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4444&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isLocal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isLocal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;LocalClientSetup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;ClientSetup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ClientSetup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NetworkClient&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;LocalClientSetup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;NetworkClient&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ClientScene&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConnectLocalServer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RegisterHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;MsgType&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Connect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;OnConnected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NetworkMessage&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Client: connected to server {0}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们把上面两个脚本都挂在 GameObject 上, 设置 SetupClient 脚本的 isLocal 字段值为 false，然后运行。输出结果为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="output" src="images/UNet/outputResult.PNG" width="88%" /&gt;&lt;/p&gt;
&lt;p&gt;代码的 Github 地址 &lt;a href="https://github.com/wudixiaop/UNet/tree/master/Assets/101%20-%20server%20and%20client"&gt;https://github.com/wudixiaop/UNet/tree/master/Assets/101%20-%20server%20and%20client&lt;/a&gt; 。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 06 Aug 2015 16:43:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-08-06:unet-0x01-wang-luo-lian-jie-de-jian-li.html</guid><category>UNet</category><category>Unity</category></item><item><title>好玩：如何把 Github Contributions 填充满</title><link>http://blog.shuiguzi.com/hao-wan-ru-he-ba-github-contributions-tian-chong-man.html</link><description>&lt;p&gt;先看效果：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="rockstar" src="images/RockStar/rockstar.PNG" width="78%" /&gt;&lt;/p&gt;
&lt;p&gt;我们要使用 RockStar 这个 python 工具来实现这个效果。RockStar 的 Github 地址 &lt;a href="https://github.com/avinassh/rockstar"&gt;撮这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RockStar 只支持 Python 3，不能在 Python 2 上面。如果本机没有 Pyhon3 可以从 &lt;a href="http://python.org"&gt;http://python.org&lt;/a&gt; 里面下载安装，当前版本的下载地址为 &lt;a href="https://www.python.org/downloads/release/python-343/"&gt;https://www.python.org/downloads/release/python-343/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用 python 前我们需要在环境变量中加入 python3 的安装路径和脚本文件的路径。假如我们安装在 &lt;code&gt;C:\Python34&lt;/code&gt; 文件夹下，则加入下面地址到环境变量 &lt;code&gt;PATH&lt;/code&gt; 中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C:\Python34;C:\Python34\Scripts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面设置完成之后我们就可以用 python 来玩耍啦。首先我们打开命令行来安装 RockStar ，输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip install rockstar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入完成之后, 我们创建一个新文件夹，比如叫做 RSFunny, 并在这个文件夹下面创建一个 python 脚本，比如叫做 rockstar.py。 脚步的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;RockStar&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;RockStar&lt;/span&gt;

&lt;span class="n"&gt;csharp_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;using System;&lt;/span&gt;

&lt;span class="s"&gt;class HelloWorld&lt;/span&gt;
&lt;span class="s"&gt;{&lt;/span&gt;
&lt;span class="s"&gt;    static void Main()&lt;/span&gt;
&lt;span class="s"&gt;    {&lt;/span&gt;
&lt;span class="s"&gt;        Console.WriteLine(&amp;quot;I&amp;#39;m Rocky&amp;quot;);&lt;/span&gt;
&lt;span class="s"&gt;    }&lt;/span&gt;
&lt;span class="s"&gt;}&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 400 天&lt;/span&gt;
&lt;span class="n"&gt;rock_it_bro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RockStar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;rockstar.cs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;csharp_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;rock_it_bro&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_me_a_rockstar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多的例子我们能参考这里 &lt;a href="https://github.com/avinassh/rockstar/tree/master/examples"&gt;https://github.com/avinassh/rockstar/tree/master/examples&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;接下来，在命令行中跳转到到 RSFunny 目录下, 准备运行 rockstar.py。这里需要注意一下，因为脚本需要用到 git.exe，所以我们需要把 git.exe 的路径加入到当前的环境变量 &lt;code&gt;PATH&lt;/code&gt; 中，不然会抛出找不到文件的错误。
如果安装了 Github for Windows 客户端，我们可以从客户端的安装目录 &lt;code&gt;%AppData%\..\Local\GitHub&lt;/code&gt; 下找到 git.exe。添加完后，我们运行脚本：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python rockstar.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行完后，脚本将 RSFunny 目录变成一个 git 仓库。&lt;/p&gt;
&lt;p&gt;好了，万事具备，只欠发布到 Github 了。 建议使用最新版 Github for Windows 客户端，简单快捷，居家旅行必备。。。&lt;/p&gt;
&lt;p&gt;不知道怎么在 Github for Windows 客户端添加？ 那就点点左上角的 + 号，然后结合下面这个截图看看，相信应有收获的。 :) &lt;/p&gt;
&lt;p&gt;&lt;img alt="gitAddRepo" src="images/RockStar/gitAddRepo.PNG" width="72%" /&gt;&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 21 Jul 2015 12:54:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-07-21:hao-wan-ru-he-ba-github-contributions-tian-chong-man.html</guid><category>Python</category></item><item><title>瞎聊 Unity Shader 系列之十一：深度缓存</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html</link><description>&lt;p&gt;第二节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt; 中提到了 Frame Buffer, 这个是用来存储帧位图的数据存储区域。 这里在介绍另外一个缓存, 叫深度缓存 (Depth Buffer), 也叫作 Z-Buffer。从名字上来看这是一个
存储深度（数据）的存储区。下面我们带着两个问题来解释这个深度缓存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;存储的深度数据是什么&lt;/li&gt;
&lt;li&gt;有什么用处&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;深度是什么&lt;/h3&gt;
&lt;p&gt;第四节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;坐标系&lt;/a&gt; 中提到，要描述一个物体的位置，需要借助参照物。我们这里扩展一下， 要 &lt;strong&gt;用数值来表述一个物体的某种属性，要有这个数值参照的原点&lt;/strong&gt;。 既然深度值是数值，那它的
参照原点是什么呢？ 答案是观察者的视角，换句话说就是 Camera。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt; 这节中提到， Vertex Shader 之后有一个插值过程，生成像素。这个像素的 X 和 Y 坐标为屏幕坐标， Z 坐标轴数值就是深度，存储在深度缓存里面。&lt;/p&gt;
&lt;h3&gt;有什么用处&lt;/h3&gt;
&lt;p&gt;首先让我们来思考一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有两个物体都经过渲染后的像素在屏幕坐标系中是同一个点，那哪个像素应该渲染？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我想现在你应该会想到，当然是渲染里观察者更近的一个像素啦。这个一般来说是对的，但是也不全对。 因为远近是用深度数值来表示，但是渲染的逻辑在 Shaderlab 里面可以用 ZTest 设置，它的语法是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ZTest&lt;/span&gt; &lt;span class="n"&gt;Less&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Greater&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;LEqual&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;GEqual&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Equal&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;NotEqual&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ZTest 默认的值是 LEqual, 也就是渲染在物体在这个深度值同位置或者之前的物体，不渲染之后的物体。&lt;/p&gt;
&lt;p&gt;你也许会想，那如果连个像素的深度值一样怎么办？ 深度值一样的情况也叫做 &lt;strong&gt;深度冲突&lt;/strong&gt; (Z-fighting)。解决方法是给其中某一个物体设置偏移量。 Shaderlab 中语法是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Offset&lt;/span&gt; &lt;span class="n"&gt;Factor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Units&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Offset 根据一个插值公式来计算出新的深度值。有兴趣的可以 &lt;a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd373973%28v=vs.85%29.aspx"&gt;参考这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们也可以打开和关闭深度写入功能，在 Shaderlab 中用 ZWrite 来控制，它的语法是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ZWrite&lt;/span&gt; &lt;span class="n"&gt;On&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;在 Unity 图像渲染中顺序中的位置&lt;/h3&gt;
&lt;p&gt;&lt;img alt="PipelineCullDepth" src="images/Shader/11/PipelineCullDepth.png" width="90%" /&gt;&lt;/p&gt;
&lt;p&gt;图片来自 Unity 官方手册 &lt;a href="http://docs.unity3d.com/Manual/SL-CullAndDepth.html"&gt;http://docs.unity3d.com/Manual/SL-CullAndDepth.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 09 Jun 2015 15:17:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-06-09:xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之十：数据的标签：语义绑定</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html</link><description>&lt;p&gt;这节内容跟 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt; 内容关系比较紧密，建议先了解渲染管线的整个流程。&lt;/p&gt;
&lt;p&gt;我们知道渲染管线整个流水线都有数据的输入输出，这样就存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这些数据都是什么？&lt;/li&gt;
&lt;li&gt;这些数据输入或输出到哪里？&lt;/li&gt;
&lt;li&gt;Shader 里面怎么体现？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这节内容主要是讲上面三个问题&lt;/p&gt;
&lt;h3&gt;数据的种类&lt;/h3&gt;
&lt;p&gt;一般情况能利用的有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;坐标系中的位置 (position)&lt;/li&gt;
&lt;li&gt;法线 (normal)&lt;/li&gt;
&lt;li&gt;切线 (tanent)&lt;/li&gt;
&lt;li&gt;颜色 (color)&lt;/li&gt;
&lt;li&gt;纹理坐标 (texture coordinate)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据的输入输出&lt;/h3&gt;
&lt;p&gt;数据存放在寄存器里面。输入的时候从寄存器读取数据，输出的时候将数据写到寄存器里面。&lt;/p&gt;
&lt;h3&gt;Shader 中的体现&lt;/h3&gt;
&lt;p&gt;首先是数据的种类的表示。现实生活中，我们也喜欢物品分类，然后对分类取个名字或贴个标签，以后我们便可以从这一类中存取属于这类的物品。Shader 里面也有类似的做法，给 Shader 函数输入输出的数据结构打上标签。
这种标签叫做 &lt;strong&gt;语义（Semantic）&lt;/strong&gt;， 打标签的行为叫做 &lt;strong&gt;语义绑定&lt;/strong&gt; 。一般用一个冒号后面带上标签的名字来表示。长相大概是这个要样子 &lt;code&gt;:XXXXX&lt;/code&gt; （XXXXX 表示语义）。&lt;/p&gt;
&lt;p&gt;我们有了标签，那我们把它放在 shader 代码什么地方呢？ 之前提到我们是给函数输入输出的数据结构打上标签，而函数的输入就是参数。对于参数，我们可以使用&lt;strong&gt;结构体&lt;/strong&gt;也可以直接使用&lt;strong&gt;基础数据类型&lt;/strong&gt;，所以能出现如下两种位置：&lt;/p&gt;
&lt;p&gt;使用基础数据类型做参数时，大概是这个样子：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;void shaderFunction(dataType variableName :XXXXX)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用结构体声明中时（这个结构体要当作 shader 函数的参数）大概是这个样子:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;struct StructName {&lt;br /&gt;
    datatype propertyName :XXXXX&lt;br /&gt;
}  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外一种是函数的输出，如果直接给返回值后面带上标签，代码会长成这个样子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dataType :XXXXX shaderFunction()&lt;br /&gt;
{&lt;br /&gt;
   .....&lt;br /&gt;
}  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是 CG 等语言&lt;strong&gt;没有像上面那么做&lt;/strong&gt;（个人觉得上面的方式会容易让人误解为标签就是返回值类型，其实不是），而是将标签移到函数的括号后面，所以最后应该只长成这个样子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dataType shaderFunction() : XXXXX&lt;br /&gt;
{&lt;br /&gt;
  ......&lt;br /&gt;
}  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，就上面3个位置。 那语义（上面的 &lt;code&gt;XXXXX&lt;/code&gt;）都有哪些呢？ 一般有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;POSITION：&lt;/strong&gt; 表示顶点在物体坐标内的位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SV_POSITION：&lt;/strong&gt; 表示被转换到投射空间后的坐标位置 (通过 UNITY_MATRIX_MVP 这个矩阵可以转换)，可以参照 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;坐标系&lt;/a&gt; 这一节内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COLOR：&lt;/strong&gt; 表示颜色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NORMAL：&lt;/strong&gt; 表示法线&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TANGENT：&lt;/strong&gt; 表示切线&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TEXCOORD0&lt;/strong&gt; 和 &lt;strong&gt;TEXCOORD1 :&lt;/strong&gt; 纹理坐标 UV0 和 UV1。UV 换个说法就是 XY 坐标，只不过是为了怕重名导致的混淆，所以叫做UV。 U 表示横坐标， V表示纵坐标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们知道通过标签来表示数据的分类, 那怎么表示输入和输出呢？答案是用关键词 in, out, inout。 光从名字上来看我们就知道 in 表示输入， out 表示输出， inout 表示输入输出。
参数如果特别表明，默认为输入。可以参考下在 Unity 编辑器里面的创建的默认 shader， 里面就有这几个关键词的用法。&lt;/p&gt;
&lt;p&gt;最后要说明一点，上面所说的在 Shaderlab 中都应该包括在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语句块里面，因为这个是 CG 等语言的内容。&lt;/p&gt;
&lt;h3&gt;举个例子&lt;/h3&gt;
&lt;p&gt;现在举个代码的例子来说明（如果对下面代码结构等不是很明白，强烈建议从头开始看本系列的文章）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Custom/Shader10&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;SubShader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Tags&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Opaque&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;

            &lt;span class="cp"&gt;#pragma vertex vert&lt;/span&gt;
            &lt;span class="cp"&gt;#pragma fragment frag&lt;/span&gt;

            &lt;span class="c1"&gt;// 结构体中使用语义绑定&lt;/span&gt;
            &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;VertexOutput&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;pos&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;SV_POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 转换到投射空间后位置&lt;/span&gt;
                &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 顶点颜色&lt;/span&gt;
            &lt;span class="p"&gt;};&lt;/span&gt;


            &lt;span class="n"&gt;VertexOutput&lt;/span&gt; &lt;span class="nf"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;pos&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;POSITION&lt;/span&gt; &lt;span class="cm"&gt;/*参数中使用语义绑定*/&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;VertexOutput&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNITY_MATRIX_MVP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="kt"&gt;float4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
             &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;frag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VertexOutput&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;COLOR&lt;/span&gt; &lt;span class="c1"&gt;// 函数后面使用语义绑定&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;ENDCG&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的 shader 如果用在立方体上渲染出漂亮的 RGB 立方体，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="rgb cube" src="images/Shader/10/rgb.png" width="40%" /&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;用语义和语义绑定来表示数据和数据的流向。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 14 May 2015 16:53:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-14:xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之九：用来包装变量的 Properties</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html</link><description>&lt;p&gt;为了像其他程序语言一样重用代码，Shaderlab 把可变部分提取出来，集中放到一个区域去。这个区域就是 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;初始 shaderlab&lt;/a&gt; 这节中提到的的 &lt;code&gt;Properties&lt;/code&gt;
可选项。 在这个区域内每一个元素被叫做 Property。我们把他叫做属性吧。这些属性都包括在 &lt;code&gt;Properties { }&lt;/code&gt; 语句块内。&lt;/p&gt;
&lt;h3&gt;Shaderlab 的属性&lt;/h3&gt;
&lt;p&gt;属性的语法是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;属性名 ("Inspector 显示的名字", 类型) = 默认值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shaderlab 提供不同的数据类型（详情见下面）。如果把这些类型和默认值格式填充进上面的语法后，会变成下面的样子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数值类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;name ("display name", Range (min, max)) = number&lt;br /&gt;
name ("display name", Float) = number&lt;br /&gt;
name ("display name", Int) = number&lt;br /&gt;
name ("display name", Color) = (number,number,number,number)&lt;br /&gt;
name ("display name", Vector) = (number,number,number,number)  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;纹理类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;name ("display name", 2D) = "defaulttexture" {}&lt;br /&gt;
name ("display name", Cube) = "defaulttexture" {}&lt;br /&gt;
name ("display name", 3D) = "defaulttexture" {}  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面 &lt;code&gt;defaulttexture&lt;/code&gt; 可以是 “white”, “black”, “gray” 或者 “bump”。&lt;/p&gt;
&lt;p&gt;对应在 Inspector 不同类型显示的默认样式如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="properties" src="images/Shader/9/properties.png" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;上面是默认样式，最后显示的样式还可以自己定制，详情可以参考 &lt;a href="http://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html"&gt;这个页面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;需要说明下，还有个 Rect 类型，在官方手册介绍 &lt;a href="http://docs.unity3d.com/Manual/SL-Properties.html"&gt;Properties 的介绍页面&lt;/a&gt; 中没有提到。估计是 Unity5 之后去掉了。&lt;/p&gt;
&lt;p&gt;注意，在 &lt;code&gt;Properites&lt;/code&gt; 语句块里面声明完了，如果要被 CG 等语言关联上，&lt;strong&gt;还需要在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语句块内 再次声明同名字的变量 后属性才起作用&lt;/strong&gt;。这个从逻辑上
好理解，因为要被 CG 等语言利用，所以应该跟 CG 等语言放在一起，而 CG 等语言程序就包括在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语句块内。&lt;/p&gt;
&lt;h3&gt;与 CG 等语言变量类型映射关系&lt;/h3&gt;
&lt;p&gt;Shaderlab 提供的类型最终会映射成 CG 等语言变量类型，他们的映射关系为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Color&lt;/strong&gt; 和 &lt;strong&gt;Vector&lt;/strong&gt; 对应为 float4, half4 或者 fixed4 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Range&lt;/strong&gt; 和 &lt;strong&gt;Float&lt;/strong&gt; 对应为 float, half, fixed 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Int&lt;/strong&gt; 对应为 int 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2D&lt;/strong&gt; 对应为 sampler2D 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cube&lt;/strong&gt; 对应为 samplerCUBE 类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3D&lt;/strong&gt; 对应为 sampler3D 类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面可以看到，有些属性是可以对应成好几类类型。Float 是 32 位高精度浮点数, half 是 16 位中等精度浮点数, Fixed 一般是 11 低位浮点数。为了性能建议使用的数据选择合适的类型。
下面有两个建议（在移动设备上尤其重要）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 Color 和 单位向量，使用 fixed 类型&lt;/li&gt;
&lt;li&gt;对于其他的类型，如果范围和精度都适合的话选择 half, 否则选择 float&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后放上上面的图片所用的 shader 代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Custom/Properties&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Properties&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;_RangeType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Range 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;
        &lt;span class="n"&gt;_FloatType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Float 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
        &lt;span class="n"&gt;_IntType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Int 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;_ColorType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Color 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;_VectorType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vector 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;_2DType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2D纹理类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;while&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="n"&gt;_CubeType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Cube 类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Cube&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;black&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="n"&gt;_3DType&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;3D纹理类型&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;gray&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="n"&gt;_RectType&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Rectangle&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;SubShader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Tags&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Opaque&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;LOD&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;

        &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;

        &lt;span class="cp"&gt;#pragma surface surf Standard fullforwardshadows&lt;/span&gt;
        &lt;span class="cp"&gt;#pragma target 3.0&lt;/span&gt;

        &lt;span class="c1"&gt;// 再次声明跟属性一样的名字的变量&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_RangeType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_FloatType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;_IntType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;_ColorType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;_VectorType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;sampler2D&lt;/span&gt; &lt;span class="n"&gt;_2DType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;samplerCUBE&lt;/span&gt; &lt;span class="n"&gt;_CubeType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;sampler3D&lt;/span&gt; &lt;span class="n"&gt;_3DType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;_RectType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;float2&lt;/span&gt; &lt;span class="n"&gt;uv_MainTex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;};&lt;/span&gt;

        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;surf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Input&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inout&lt;/span&gt; &lt;span class="n"&gt;SurfaceOutputStandard&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Alpha&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;ENDCG&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Fri, 08 May 2015 14:13:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-08:xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之八：#pragma 指令</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html</link><description>&lt;p&gt;第三节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;Shader 土地上的语言们&lt;/a&gt; 里面说到过 CG 和 HLSL 等语言被 &lt;code&gt;GGPROGRAM ... ENDCG&lt;/code&gt; 语句块里面。这节的主角 #pragma 出现的位置就是在这个语句块里面，用来做编译指示的。就好比告诉
 Shaderlab 的编译器，你应该这么干应该那么干。这里把 #pragma 叫做编译指令吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语句块根据 Shaderlab 写作方式不同，它的位置也不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是 &lt;strong&gt;surface shader&lt;/strong&gt;, 它在 Subshader 语句块里面，不是在 Pass 语句块里面&lt;/li&gt;
&lt;li&gt;如果是 &lt;strong&gt;vertex&amp;amp;&amp;amp;framgment shader&lt;/strong&gt;，它是 Pass 语句块里面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实 surface shader 最终会编译成 vertex&amp;amp;&amp;amp;framgment shader, 最终结果是一样的的。surface shader 会被编译成含多个 Pass 的 vertex&amp;amp;&amp;amp;fragment shader, 而这些都用相同的编译指令。我们可以从 Inspector 的 shader
属性信息里面去打开被编译为 vertex&amp;amp;&amp;amp;fragment shader 后的代码。&lt;/p&gt;
&lt;p&gt;&lt;img alt="surface shader" src="images/Shader/8/surfaceshader.png" width="61%" /&gt;&lt;/p&gt;
&lt;p&gt;如果本身不是 surface shader 的话，上面那个 show generated code 按钮是不会出现的。上面提到 #pragma 是在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语句块里面的，所以它出现的位置也符合上面提到的特征。&lt;/p&gt;
&lt;h3&gt;Surface Shader 的编译指令&lt;/h3&gt;
&lt;p&gt;这类 shader 必须指明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;surfaceFuction 是什么&lt;/li&gt;
&lt;li&gt;关照模型是什么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语法是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#pragma surface surfaceFunction lightModel [optionalparams]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面语法能知道，它有一些可以选的参数。具体参考 &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;这个页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伪代码大概是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="c1"&gt;// CGPROGRAM ... ENDCG 在 Subshader 里面&lt;/span&gt;
       &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;

       &lt;span class="c1"&gt;// surfaceFunction 是 surf,&lt;/span&gt;
       &lt;span class="c1"&gt;// 光照模型是 Standard&lt;/span&gt;
       &lt;span class="c1"&gt;// [...] 表示可选参数&lt;/span&gt;
       &lt;span class="cp"&gt;#pragma surface surf Standard [...]&lt;/span&gt;


      &lt;span class="c1"&gt;// surfaceFunction&lt;/span&gt;
      &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;surf&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

       &lt;span class="p"&gt;}&lt;/span&gt;

       &lt;span class="n"&gt;ENCG&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Vertex&amp;amp;&amp;amp;Fragment Shader 的编译指令&lt;/h3&gt;
&lt;p&gt;这里的指令集分三类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CG/HLSL 程序相关&lt;/li&gt;
&lt;li&gt;面向的 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;渲染的平台&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体参考 &lt;a href="http://docs.unity3d.com/Manual/SL-ShaderPrograms.html"&gt;这个页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;伪代码大概是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// CGPROGRAM ... ENDCG 在 Pass 里面&lt;/span&gt;
            &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;

            &lt;span class="c1"&gt;// vertex shader 的函数是 vert&lt;/span&gt;
            &lt;span class="cp"&gt;#pragma vertex vert&lt;/span&gt;

            &lt;span class="c1"&gt;// fragment shader 的函数是 fragment&lt;/span&gt;
            &lt;span class="cp"&gt;#pragma fragment frag&lt;/span&gt;

            &lt;span class="n"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;frag&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;ENDCG&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码中的 vertex shader 和 fragment shader 在渲染管道中的位置请参考这系列文章第二节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管道&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 07 May 2015 16:13:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-07:xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之七：究竟谁先被渲染？</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html</link><description>&lt;p&gt;这节的问题: 假设有很多对象需要渲染，而你想自己指定这些对象被渲染的顺序的话应该怎么做？&lt;/p&gt;
&lt;p&gt;先上答案：使用 Subshader 的 Queue 标签指定。&lt;/p&gt;
&lt;p&gt;那 Queue 标签又是是那么？？ 我们继续往下看，先介绍 Subshader 的标签&lt;/p&gt;
&lt;h3&gt;Subshader 的标签&lt;/h3&gt;
&lt;p&gt;在上一节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;初识 Shaderlab&lt;/a&gt; 中我们知道 Subshader 语句块内有个 &lt;code&gt;[Tags]&lt;/code&gt; 可选项，它的作用是是配置渲染引擎应该 &lt;strong&gt;什么时候 和 怎么样&lt;/strong&gt; 去渲染。这就是 Subshader 的标签。&lt;/p&gt;
&lt;p&gt;它的语法是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "TagName1" = "Value1" "TagName2" = "Value2" ... }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是 Tags 语法块内带有若干键值对项（理论上可有很多很多个这种键值对）。可以填写的些键值对可以参考 &lt;a href="http://docs.unity3d.com/Manual/SL-SubshaderTags.html"&gt;这个页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要注意一点 &lt;strong&gt;它只能写在 Subshader 语句块里面，不能写在 Pass 语句块里面&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;Queue 标签&lt;/h3&gt;
&lt;p&gt;Queue 标签是上面提到的可选键值对项中的一个，也就是决定对象被渲染顺序的标签。根据上面的语法，我们可以这么写：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "Queue" = "XXXX" }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的 &lt;code&gt;XXXX&lt;/code&gt; 是 Queue 标签的值，这个值在内部是整数型的索引。&lt;strong&gt;数值越小，越先被渲染&lt;/strong&gt;。但是不要以为直接填整数就可以，Shaderlab 不支持直接填数值，而是先定义好了 5 个具有描述性的词来代替单调的数值。他们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Background：&lt;/strong&gt; 对应数值为 1000，用于需要被最先渲染的对象，如背景什么的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geometry：&lt;/strong&gt; 对应数值为 2000, 用于不透明的物体。这个是默认的选项（如果不指明 Queue 标签的值，自动给你指定为 Geometry）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AlphaTest：&lt;/strong&gt; 对应的数值为 2450, 用于需要使用 AlphaTest 的对象来提高性能。AlphaTest 类似于裁剪 (clip) 功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transparent：&lt;/strong&gt; 对应的数值为 3000， 用于需要使用 alpha blending 的对象，比如粒子，玻璃等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Overlay：&lt;/strong&gt; 对应的数值为 4000，用于最后被渲染的对象，比如 UI。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;渲染顺序的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="queue" src="images/Shader/7/queue.png" width="73%" /&gt;&lt;/p&gt;
&lt;p&gt;前面提到虽然 Queue 内部是整型数值，但是写 shader 的时候不能给它指定整型数值，那要是前置给它指定为整型数值会怎么样？&lt;/p&gt;
&lt;p&gt;答案是：会被忽略，使用默认的值，也就是 Geometry。同样的，随便填写的值也是会被忽略并使用默认值代替。 比如 &lt;code&gt;asd1123&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还有 Shaderlab 还对上面五类做了延伸，让他们 &lt;strong&gt;支持加减法&lt;/strong&gt;。比如想让对象在 Background 之后 Geometry 之前渲染，我们可以这么写:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "Queue" = "Geometry-1"}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有几点比较重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Geometry-1&lt;/code&gt; 中间不能有空格&lt;/li&gt;
&lt;li&gt;这个语法是整型数值的加减法。 &lt;code&gt;Geometry-1&lt;/code&gt; 和 &lt;code&gt;Background+999&lt;/code&gt; 得到的结果是一样的，因为 2000 - 1 = 1000 + 999。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在 Unity 编辑器里面选中 shader 文件，然后从 Inspector 里查看 Shader 的 Render queue 属性值，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="render queue" src="images/Shader/7/geometry_1.png" width="60%" /&gt;&lt;/p&gt;
&lt;p&gt;最后基于上一节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;初识 Shaderlab&lt;/a&gt; 中的精简骨架，我们来写一个伪代码，看看插入 Queue 标签后的样子。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="n"&gt;SubShader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Tags&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Transparent&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 07 May 2015 16:13:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-06:xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之六：初识 Shaderlab</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html</link><description>&lt;p&gt;好吧，其实这不算初识 Shaderlab 了，因为在 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;shaderlab 土地上的语言们&lt;/a&gt; 这节中已经说到在 shaderlab 中有三种方式来写 shader。
这节的内容主要是来认识下 shaderlab 语法写出来的 shader 长得什么样子。&lt;/p&gt;
&lt;p&gt;下面有段基于 shaderlab 的 shader 的大概框架的伪代码，在之前要解释下代码中带中括号的部分，如 &lt;code&gt;[Properties]&lt;/code&gt;, 表示是可以选择的，也就是说可以不写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//shader 的名字会显示在 Unity 的 Inspector 中选择 shader 的菜单里面&lt;/span&gt;
&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 属性&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Properties&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 可能存在多个 subshader。Unity 会在所有 subshader 列表中选择当前环境中可用的第一个 subshader&lt;/span&gt;
    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// subshader 的标签&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 给多个 pass 公用的设置&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Common&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 可能存在多个 pass, 每个 pass 都会引起一次渲染过程&lt;/span&gt;
        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// pass 的标签&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 渲染设置, 如颜色混合&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Render&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 纹理设置，只有在 fixed function shader 中才可用&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Texture&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 可以有多个 pass&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Pass&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 可以有多个 subshader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Subshader&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当所有 subshader 失败的时候, 使用 Fallback 指定的 shader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Fallback&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当有自定义 shader 的设置 UI 时候用&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CustomEditor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面伪代码中的注释解释了各个部分的作用，如果去除可选部分，最后就留下&lt;strong&gt;精简的骨架&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而大部分 shader 都是在上面代码基础上扩展的。&lt;/p&gt;
&lt;p&gt;这节就到这里，会在后面的章节继续聊 shaderlab。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 05 May 2015 17:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-05:xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之五：RGBA 101</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html</link><description>&lt;p&gt;这节说说 fragment shader 最后输出的像素的颜色表示方法 RGBA。&lt;/p&gt;
&lt;p&gt;玩过 Photoshop 的同学可能知道，存在好几种颜色模式来表示颜色，&lt;a href="http://baike.baidu.com/view/1139658.htm"&gt;比如 RGB 和 CMYK&lt;/a&gt;. 由于显示器的发光物体，所以使用的 RGB 模式。
Unity 中也采用这种表示方法。&lt;/p&gt;
&lt;h3&gt;RGB模式&lt;/h3&gt;
&lt;p&gt;RGB是用红绿蓝混合来表示的颜色。R 是红色， G 表示绿色， B 是蓝色。一般用8为来表示一个颜色通道，每个通道有 256 个等级（0~255）。它有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(0, 0, 0)&lt;/code&gt; 表示黑色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(255, 255, 255)&lt;/code&gt; 表示白色&lt;/li&gt;
&lt;li&gt;三个通道数值相同的时候是灰色，比如 &lt;code&gt;(128, 128, 128)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数值越大颜色越亮，反之数值越小越暗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="RGB" src="images/Shader/5/rgb.png" width="61%" /&gt;&lt;/p&gt;
&lt;p&gt;但是 Unity Shader 中并不用 256 个等级来表示颜色数值，而是用标准化（取值0~1）的数值来表示。换句话说就是所有通道都除以 255 得到标准化的结果。&lt;/p&gt;
&lt;h3&gt;RGBA 中的 A 是什么&lt;/h3&gt;
&lt;p&gt;A 叫做 alpha，其数值表示不透明度。 据说提出者用 alpha 来命名源于经典的线性插值方程 αA + (1-α)B 所用的希腊字母 α。Unity 中的 aplha blending 基于这个线性方程。&lt;/p&gt;
&lt;h3&gt;混合模式&lt;/h3&gt;
&lt;p&gt;抽象一下就是对两个颜色做运算后得到结果颜色的过程。这个过程其实就是个运算公式。下面列举两个 Photoshop 中常见的正片叠底和滤色两个混合模式的计算公式。C为结果色，A 和 B 是需要混合的颜色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正片叠底(Multiply):&lt;/strong&gt; C=A*B&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滤色(Screen):&lt;/strong&gt; C=1-(1-A)*(1-B)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们要叠加模型多个贴图（比如法线贴图和模型贴图）的时候就可以利用到混合模式。更多混合模式公式参考&lt;a href="http://wenku.baidu.com/view/da9d22d9ad51f01dc281f1f9.html"&gt;这个文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 04 May 2015 13:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-05-04:xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之四：坐标系</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html</link><description>&lt;p&gt;这节从很平常一段对话开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲跟乙说：&lt;/strong&gt; 喂，你看到那个人没有？&lt;br /&gt;
&lt;strong&gt;乙：&lt;/strong&gt; 你说的是哪个？&lt;br /&gt;
&lt;strong&gt;甲：&lt;/strong&gt; 就是那棵树旁边那个。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从对话里面我们知道：&lt;strong&gt;要描述一个物体的位置，我们需要借助参照物。&lt;/strong&gt; 其实甲也可以这么说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲：&lt;/strong&gt; 在那个个子很高的人左手边那位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说 &lt;strong&gt;参照物是可以选择的，可变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们把上面对话推广到坐标系上，来给坐标系下个山寨的定义：&lt;strong&gt;坐标系是为了描述物体位置而存在，我们借助的参照物是它的原点
。由于可以选择不同的参照物，所以我们可以选择不同的原点。&lt;/strong&gt; 原点很重要，我们利用坐标系的时候首先要知道原点在哪里。&lt;/p&gt;
&lt;p&gt;既然原点可以任意选，那不是说会出现很多坐标系？ 是的，但是我们使用几种约定的坐标系就好了。&lt;/p&gt;
&lt;h3&gt;那些坐标系们&lt;/h3&gt;
&lt;p&gt;下面是我们平时会碰到的一些坐标系。按规定，原点的各个轴是数值都是 0 来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物体坐标系 (Object Space)：&lt;/strong&gt; 有时也叫做 Local Space。是 3D 模型内部的坐标系，原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 一般是模型中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;世界坐标系 (World Space)：&lt;/strong&gt; Unity 系统中的绝对坐标系，原点是在场景的 &lt;code&gt;(0，0，0)&lt;/code&gt; 位置处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视口坐标系 (Viewport Space)：&lt;/strong&gt; 以摄像机为原点，朝向为 Z 轴的坐标系。原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 是摄像机的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕坐标系 (Screen Space)：&lt;/strong&gt; 原点 &lt;code&gt;(0, 0)&lt;/code&gt; 在屏幕的左下角，右上角为 &lt;code&gt;(Screen.width，Screen.height)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那问题来了。这些坐标系们有什么关系？&lt;/p&gt;
&lt;p&gt;我们以立方体为例。我们从&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;小节中知道，Mesh Renderer 组件得到模型数据之后它会执行 vertex shader（Unity 默认的 Shader 给我提供了）。
vertex shader 里面做了下面这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先把立方体从模型的物体坐标系转换成世界坐标系，&lt;strong&gt;从 物体 到 世界&lt;/strong&gt;。这样子，它和摄像机（世界坐标）的位置就用同一个坐标系描述了。&lt;/li&gt;
&lt;li&gt;再把立方体从世界坐标转换成视口坐标系，也就是摄像机因为原点的坐标系，&lt;strong&gt;从 世界 到 视口&lt;/strong&gt;。这样它是在摄像机的正面，还是在反面了。&lt;/li&gt;
&lt;li&gt;最后在投射到屏幕坐标系上， &lt;strong&gt;从 视口 到 屏幕&lt;/strong&gt;。这样知道哪些区域需要绘制在屏幕上，哪些不需要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结上面一系列变换关系就是： &lt;strong&gt;物体 到 世界 再到 视口 再到 屏幕&lt;/strong&gt;。中间经过了三次变换 (transform)。这些变换在数学上通过 &lt;strong&gt;矩阵&lt;/strong&gt; 来描述的。这里有个知识点：
矩阵可以表示变换。在这里推荐关于 3D 数学的一本经典好书 &lt;a href="http://pan.baidu.com/s/1eQ8eSYQ"&gt;《3D数学基础图形与游戏开发》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;到现在是不是有种跃跃欲试，但是想想又头大的感觉，在 Unity 里面这些矩阵具体的数值是什么？要是自己去运算那多复杂啊。别急，Unity 给我们已经提供了这些矩阵当作 Shader
的内置变量（&lt;a href="http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html"&gt;详情参考这个链接&lt;/a&gt;），可以在编程的时候直接使用。在这里只是说一下，我们利用 &lt;code&gt;UNITY_MATRIX_MVP&lt;/code&gt;
 这个矩阵就可以达到变换到屏幕坐标系的目的。至于怎么做，会在以后的文章中会提到。&lt;/p&gt;
&lt;h3&gt;左手和右手坐标系&lt;/h3&gt;
&lt;p&gt;这两不是新坐标系，是建立三维坐标系的两种选择。换句话说对于处于同一个物体，可以用基于左手坐标系规则来建立三维坐标系，也可以用基于右手坐标系规则来建立三维空间，他们的区别是坐标轴的数值会有差异。&lt;/p&gt;
&lt;p&gt;为什么叫做左手和右手，看看下面的图就知道了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="leftAndright" src="images/Shader/4/leftandRightHandCoordinate.png" width="80%" /&gt;&lt;/p&gt;
&lt;p&gt;一般情况下左手和右手坐标系的数值做转换的话只需把 Z 值乘以 -1 即可。比如左手坐标系的 &lt;code&gt;(1, 1, 1)&lt;/code&gt; 转成为右手坐标系是  &lt;code&gt;(1, 1, -1)&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 30 Apr 2015 13:55:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-30:xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之三：Shader 土地上的语言们</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html</link><description>&lt;p&gt;这节是关于 Unity 平台上 shader 语言的选择。&lt;/p&gt;
&lt;p&gt;计算机行业的各公司（或者组织）似乎都遵循着某种规则。当他们在某个领域划出了一亩三分地，当上了地主后, 就要用方法圈住干活的农民。让他们觉得在我这里不会饿死，有饭吃，你要到别家
干活的话，需要重头再来，这是一个很亏本的买卖。这个方法就是制定自己体系（软硬件中的各种协议，接口，语言，框架），脱离这套体系，在别的地方玩不起来。开个玩笑来取名这个规矩叫做&lt;strong&gt;圈地规则&lt;/strong&gt;吧。&lt;/p&gt;
&lt;h3&gt;Shader 语言们&lt;/h3&gt;
&lt;p&gt;根据上面提到的圈地规则，下面来隆重的介绍下 shader 这块地上地主们建立起来的体系：CG, HLSL 和 GLSL 语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CG：&lt;/strong&gt; C for Graphics 的简称，是 NVIDIA 公司开发的语言。从名字上来看的出它是 C 语言的亲戚，现实是它保留了 C 语言的大部分语义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HLSL：&lt;/strong&gt; High Level Shader Language 的简称，由微软开发的语言。语法跟 CG 非常的相似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GLSL：&lt;/strong&gt; OpenGL Shading Language 的简称，OPENGL 组件开发的，语法也是基于 C 语言的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么问题来了，Shader 语言到底哪家强？这个也发生过强烈的讨论。&lt;/p&gt;
&lt;p&gt;其实这个问题好回答，既然跟着 Unity 地主干，听 Unity 地主的话就好了。那么另外一个问题又来了，Unity 地主的观点又是什么？&lt;/p&gt;
&lt;h3&gt;Unity 体系规则 Shaderlab&lt;/h3&gt;
&lt;p&gt;根据圈地规则，Unity 地主也有自己的体系，那就是 Shaderlab。那 shaderlab 又是什么呢？ 这是一个能包容 CG, HLSL 和 GLSL，并且有自己语法体系的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能包容 CG, HLSL, 和 GLSL 意思是说在它里面能使用这三种语言。Shaderlab 中用特定的语法块来指定他们：&lt;ul&gt;
&lt;li&gt;GG 和 HLSL 包括在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;li&gt;GLSL 包括在 &lt;code&gt;GLSLPROGRAM ... ENDGLSL&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有自己的语法系统是指它有自己独特的语法，并且独立于上面三种语言（这句似乎是废话。。。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unity 官方比较提倡 CG 或 HLSL 语言。所以我们首选这两个中的其中一个了。之前提到，其实这两语法非常相似，所以其实学好了其中一门就差不多等于学了两门语言。（好像很划算的样子！）&lt;/p&gt;
&lt;h3&gt;在 Shaderlab 中写 Shader 的三种方式&lt;/h3&gt;
&lt;p&gt;Unity 手册 Shader 参考章节&lt;a href="http://docs.unity3d.com/Manual/SL-Reference.html"&gt;开篇&lt;/a&gt;就写道 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shaders in Unity can be written in one of three different ways:&lt;/p&gt;
&lt;p&gt;as &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;&lt;strong&gt;surface shaders&lt;/strong&gt;&lt;/a&gt;,&lt;br /&gt;
as &lt;a href="http://docs.unity3d.com/Manual/SL-ShaderPrograms.html"&gt;&lt;strong&gt;vertex and fragment shaders&lt;/strong&gt;&lt;/a&gt; or&lt;br /&gt;
as fixed function shaders.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说有三种 shader 的变体。&lt;/p&gt;
&lt;h4&gt;Fixed function shaders&lt;/h4&gt;
&lt;p&gt;这种 shader 一般用于不支持可编程 shader 模型的老设备上面， 比如 iPhone3。Unity 用 shaderlab 的语法来配置。&lt;/p&gt;
&lt;h4&gt;vertex and fragment shaders&lt;/h4&gt;
&lt;p&gt;参考名字，这个主要是玩转 vertex 和 fragment shader 的。参考&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;章节可以知道这两个 shader 处于什么位置。&lt;/p&gt;
&lt;h4&gt;surface shaders&lt;/h4&gt;
&lt;p&gt;Unity 提倡如果想写跟光线交互的 shader 使用这种方式写。那 surface shader 又是什么。 &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;Unity 手册里面有段话道出了真相：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Surface Shader compiler then figures out what inputs are needed, what outputs are filled and so on, &lt;strong&gt; and generates actual vertex&amp;amp;pixel shaders,&lt;/strong&gt;
as well as rendering passes to handle forward and deferred rendering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来 surface shader 最终会被编译成 vertex&amp;amp;fragment shader，这只是换了个汤。当然汤里家里点佐料就是 Unity 帮你处理光线而不用自己写算法。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;Unity Shaderlab 是基于shader语言上建立了自己的一套语法规则，我们不仅要学习 shaderlab 语法，也要学习 shader 语言。Unity 官方提倡使用 CG 或 HLSL 语言。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.unity3d.com/Manual/ShadersOverview.html"&gt;Unity Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1rsaho"&gt;GPU 编程与CG 语言之阳春白雪下里巴人&lt;/a&gt;（点击链接即可下载），推荐此书。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 04 May 2015 14:33:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-29:xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之二：渲染管线</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html</link><description>&lt;p&gt;这节描述的是图形渲染的大致过程。&lt;/p&gt;
&lt;p&gt;为了更好理解和记忆这节内容，先来学下面几个词。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染管线(Rendering Pipeline)：&lt;/strong&gt; 一提到管线，感觉很高大上的样子。说的俗一点就是可以理解为流水线。渲染管线我们可暂时理解为 &lt;strong&gt;从得到模型数据到绘制出图像&lt;/strong&gt; 这一过程的称呼。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vertex Shader：&lt;/strong&gt; 对顶点数据编程的一段程序。 人类有懒惰的天性，习惯用简化的词汇来表达同一个东西。对 Vertex Shader 也不例外，一般称其为 VS ，但是在本系列文章中会保持全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fragment Shader：&lt;/strong&gt; 对像素数据编程的一段程序。这里 fragment 可以理解为带有信息（颜色，坐标等）的像素 (Pixel), 一般也简称其为 FS 或者 PS 。 在本系列文章中会保持其全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FrameBuffer：&lt;/strong&gt; 缓存帧数据的存储区，它一般包含的是要显示到显示设备上的位图数据（也就是图片数据）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fixed Function：&lt;/strong&gt; 由于一些硬件支持等历史原因，早期的图形 API  &lt;strong&gt;只支持对 GPU 做配置&lt;/strong&gt;，这部分只可配置的功能就是 fixed fucntion。
这里注意下，fixed function 的功能只能配置，不像 Vertex Shader　和 fragment Shader 可以编程（写自己的算法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染管线 (Rendering Pipeline)&lt;/h3&gt;
&lt;p&gt;看图说话&lt;/p&gt;
&lt;p&gt;&lt;img alt="2.renderingpipeline.jpg" src="images/Shader/2/rendering-pipeline.jpg" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;上面是可编程的渲染管线模型的示意。下面多说几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入阶段。Unity 使用 Mesh Renderer 等组件读取模型顶点数据，然后调用图形 API，将数据传递给 GPU。&lt;/li&gt;
&lt;li&gt;现实中同时会进行多条渲染管线，他们是&lt;strong&gt;并行的&lt;/strong&gt;。 这点概念比较重要，以后还会提到它。我们记住 GPU 并行能力很强。&lt;/li&gt;
&lt;li&gt;最后输出的 FrameBuffer (可以理解为渲染出来的图片) 有几率被抛弃掉，也就是说不显示在显示设备上。这个以后单独说明原因。好比残酷的现实世界，努力了（整个渲染过程）也不一定会成功（被显示出来）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;渲染管道是从得模型数据到图像生成过程的一种描述。Vertex Shader 能对顶点数据写处理算法，而 Fragment Shader 能对像素数据写处理算法。&lt;/p&gt;
&lt;h3&gt;参考：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikibooks.org/wiki/Cg_Programming/Programmable_Graphics_Pipeline"&gt;Cg Programming in Unity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fixed-function"&gt;Fixed-function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鄙人才疏学浅，有出入的地方非常感谢能帮忙指正。:)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 28 Apr 2015 14:07:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-28:xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html</guid><category>Shader</category></item><item><title>瞎聊 Unity Shader 系列之一：GPU 与 Shader Model</title><link>http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</link><description>&lt;p&gt;我想首先唠叨下我为什么打算写这一系列的文章及文章的定位。&lt;/p&gt;
&lt;p&gt;我写的动力主要来源于如下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对之前学习的一些总结、复习和提炼&lt;/li&gt;
&lt;li&gt;尽可能的填充一些概念上的空白。 有不少关于 Unity shader 的文章只讲 Shaderlab 语法，讲各种光照模型等, 这对于缺乏概念的新手来说是不太好理解的。&lt;/li&gt;
&lt;li&gt;之前信誓旦旦的跟朋友说以后学了 shader 会写点文章出来，算是允诺。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章定位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是学习笔记，不是教程。如果内容会有出入，非常感谢和希望您能指正。&lt;/li&gt;
&lt;li&gt;主要基础概念为主，可能很零散。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前有前辈说过，学习一门知识前，了解其由来对入门很有好处。我比较赞同这个观点，所以开篇我们来说写历史。&lt;/p&gt;
&lt;h3&gt;CPU 之外的另外一个 PU - GPU&lt;/h3&gt;
&lt;p&gt;随着计算机处理图形的计算量越来越来大，CPU难以满足计算速度上的需求, 为了将图形的计算单独拿出来执行，上世纪70年代开始出现了为加速图形绘制的硬件。
这些硬件跟大部分刚出来的新事物一样，功能有限，而且不太完善，当然那个时候也不叫 GPU。&lt;/p&gt;
&lt;p&gt;1999 年，NVIDIA 公司发布了 GeForce256, 并且提出一个 Graphics Process Unit (GPU) 概念。很多文章都提到这款显卡有划时代的意义，因为它使第一款
带有可编程顶点处理能力的显卡，这意味着显卡从&lt;strong&gt;之前的只可配置&lt;/strong&gt;上升到了&lt;strong&gt;可编程&lt;/strong&gt;的高度，开发者从此可以实现自己顶点处理算法。NVIDIA 也是提出 GPU 这个词
来对 GeForece256 与之前显卡做区分。&lt;/p&gt;
&lt;p&gt;2000 年以后， GPU 技术一直在不断的发展，处理和运算能力不断打变强变大。为了利用 GPU 强大的并行计算能力，出现了 CUDA 并行计算平台。有兴趣的同学可以关注下
&lt;a href="https://developer.nvidia.com/cuda-zone"&gt;CUDA官网&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Shader Model&lt;/h3&gt;
&lt;p&gt;首先我们要提下当今跟 GPU 打交道的形API：&lt;a href="http://en.wikipedia.org/wiki/DirectX"&gt;Microsoft DirectX&lt;/a&gt;、 &lt;a href="https://www.opengl.org"&gt;OPENGL&lt;/a&gt; 和
 转为嵌入式设备设计的&lt;a href="https://www.khronos.org/opengles/"&gt;OPENGL GS&lt;/a&gt;。Directx 是微软提供的图形 API, OPENGL 和 OPENGL ES 现在是由 &lt;a href="http://baike.baidu.com/link?url=vW0PfmVKQC00WWRibyVSrnjRYVdVj1lk9HG6B4w9uc9lnlnWnYoDJd1puZu1CNf2_vacBBTFFbdMzZWCNkliSK"&gt;Khronos Group&lt;/a&gt; 团队维护开发的图形API。&lt;/p&gt;
&lt;p&gt;这些图形 API 都提供对 GPU 编程的能力，这能力就是我们说的 Shader。图形 API 的更新会提供不同的 shader 的能力 (当然是越来越强大)。
微软提出了一个词叫 Shader Model, 并用不同的版本号来区分 Shader 的能力。通常我们也会称 Shader Model 为 SM。&lt;/p&gt;
&lt;p&gt;下面列出到现在为止 Shader Model 的各个版本与 DirectX 版本的对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shader Model 1.0（DirectX8.0）&lt;/li&gt;
&lt;li&gt;Shader Model 2.0（DirectX9.0b）&lt;/li&gt;
&lt;li&gt;Shader Model 3.0（DirectX9.0c）&lt;/li&gt;
&lt;li&gt;Shader Model 4.0（DirectX10）&lt;/li&gt;
&lt;li&gt;Shader Model 4.1（DirectX10.1）&lt;/li&gt;
&lt;li&gt;Shader Model 5.0（DirectX11）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先不关注各个版本区别，只要知道版本号越高，提供的功能越来越强大。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;GPU 为大量图形计算而生，而 Shader 是对 GPU 编程的技术。微软用 Shader Model 的不同版本号来区分不同 Shader 的能力。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphics_processing_unit"&gt;Wikipidia: Graphics processing unit &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/gp/product/1568814240?tag=realtimerenderin&amp;amp;pldnSite=1"&gt;&lt;em&gt;Real-Time Rendering, Third Edition&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/link?url=DDy0sTi56RE9TiVdj5MOCqwmV7ATJEkBHQp7V8eRzA_lyq1HPOLgmBULeSo-Khw2-mb7Wst75LJF3_I3SjZAZa"&gt;Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-ba-pragma-zhi-ling.html"&gt;瞎聊 Unity Shader 系列之八：#pragma 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-jiu-yong-lai-bao-zhuang-bian-liang-de-properties.html"&gt;瞎聊 Unity Shader 系列之九：用来包装变量的 Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-shu-ju-de-biao-qian-yu-yi-bang-ding.html"&gt;瞎聊 Unity Shader 系列之十：数据的标签：语义绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity-shader-xi-lie-zhi-shi-yi-shen-du-huan-cun.html"&gt;瞎聊 Unity Shader 系列之十一：深度缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Mon, 27 Apr 2015 15:54:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-26:xia-liao-unity-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</guid><category>Shader</category></item><item><title>在 Unity uGUI 中绘制圆形图片</title><link>http://blog.shuiguzi.com/zai-unity-ugui-zhong-hui-zhi-yuan-xing-tu-pian.html</link><description>&lt;p&gt;最近项目需要在 Unity 的新 UI 系统中实现圆形头像的功能，之前想通过 Mask 控件的方式来实现，但是一番努力后毫无头绪，只能祭上shader了。&lt;/p&gt;
&lt;p&gt;大体的思路就是在一个空的 Object 上面挂上 RawImage 组件，组件的 Material 挂上本文中的 shader。截取的逻辑是选取图片正中心 (0.5, 0.5) 为圆的中心点，绘制图片在圆内的像素点为图片的像素，然后图片在圆外的像素点设置为 alpha 为 0 的点，
如 &lt;code&gt;(0, 0, 0, 0)&lt;/code&gt;。逻辑是在 fragment shader 里面实现(shader 代码中的&lt;code&gt;frag&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下面直接放出 shader:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Sprites/Circle&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Properties&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PerRendererData&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sprite Texture&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;_Color&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Tint&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Center&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Radius Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Horizontal Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
    &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vertical Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;SubShader&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Tags&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;Queue&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Overlay&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;IgnoreProjector&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Transparent&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;PreviewType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Plane&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;CanUseSpriteAtlas&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Cull&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Lighting&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;ZWrite&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Blend&lt;/span&gt; &lt;span class="n"&gt;One&lt;/span&gt; &lt;span class="n"&gt;OneMinusSrcAlpha&lt;/span&gt;

    &lt;span class="n"&gt;Pass&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma vertex vert&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma fragment frag&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma multi_compile _ PIXELSNAP_ON&lt;/span&gt;
      &lt;span class="cp"&gt;#include &amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;appdata_t&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;v2f&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;half2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="nf"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;appdata_t&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNITY_MATRIX_MVP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="cp"&gt;#ifdef PIXELSNAP_ON&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnityPixelSnap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="cp"&gt;#endif&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="n"&gt;sampler2D&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;frag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_Target&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tex2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// adjust center and horizontal/verital scale&lt;/span&gt;
        &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;

          &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;ENDCG&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Github 地址： &lt;a href="https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader"&gt;https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 15 Apr 2015 23:30:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-04-15:zai-unity-ugui-zhong-hui-zhi-yuan-xing-tu-pian.html</guid><category>Unity</category></item><item><title>一个例子学习Swift中的闭包用法</title><link>http://blog.shuiguzi.com/yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</link><description>&lt;p&gt;初学习Swift, 觉得Swift中的闭包用法比较灵活, 所以在学习的时候编了个小例子来把用法罗列了出来, 分享出来给大家。&lt;/p&gt;
&lt;p&gt;在讲例子之前我们来看下什么是闭包(Closure).《The Swift Programming Language》是这样定义的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Closures are self-contained blocks of functionality that can be passed around and used in your code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文版中这样翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看解释我们知道，闭包是代码段，它能实现一些逻辑（函数），它可以被传递和使用（就像类型一样）。&lt;/p&gt;
&lt;p&gt;然后我们来看看闭包长的什么样子。下面是闭包的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ (parameters) -&amp;gt; returnType in
   statements
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面定义中 &lt;strong&gt;parameters&lt;/strong&gt; 是指参数， &lt;strong&gt;returnType&lt;/strong&gt; 是返回类型，而 &lt;strong&gt;statements&lt;/strong&gt; 指的是我们要实现的逻辑的代码, 闭包的代码都被 &lt;strong&gt;{}&lt;/strong&gt; 包含着。
观察力强的同学们估计发现了，它怎么跟Swift的函数长的差不多，难道它们是亲戚? Swift中函数是一种特殊的闭包，记住函数是闭包，不是闭包是函数哦。&lt;/p&gt;
&lt;p&gt;接下来我们说说文章开头提到的那个栗子。&lt;/p&gt;
&lt;p&gt;假设我们要找出某一些人中最小年龄是多少，我们要通过排序的方法来得到这个年龄。有这么一组年龄数字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;ages&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先我们使用最原始的办法，自己定义排序方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中我们定义了一个叫做 sortAge 的函数, 它传递给了第二个参数的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Bool&lt;/code&gt; 的 sorted 函数。 如果用闭包来代替自定义的函数, 写法就变成了这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个闭包用法就写好了。上面闭包中，定义了参数的个数，名字还有其类型，定义了返回值，还有代码体(in 关键词之后的代码)。
看起来就像重新写了一个 sortAage 函数。你可能会想，这样也没省多少事，只不过是把自定义的函数写到了 sorted 函数的参数里而已。
别急, 学会聪明的偷懒是一个好程序员属性，我们来看看怎么简化上面的代码。&lt;/p&gt;
&lt;p&gt;首先&lt;strong&gt;闭包中如果能从上下文推断出其参数类型，我们可以省略其类型的定义&lt;/strong&gt;。sorted 函数的, 所以我们可以简化代码为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，用来包含参数的括号我们可以省略掉, 变成了下面这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包代码体中只包含单行代码, 我们可以省略 return 关键词&lt;/strong&gt;, 然后变成了这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包中返回类型能从上下文推断出，我们可以省略返回值定义&lt;/strong&gt;。参照上面 sorted 函数第二个参数的定义，是可以推断出闭包返回值是 Bool。省略之后就变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到了这里，代码已经比较清爽了。但是偷懒的步伐还可以继续（懒惰是人类文明进化的动力）。Swift 闭包中允许用 $0, $1 $2 这样用 $n 这种符号后面接数字的形式来表示其第n个参数. 然后就可以变成这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，已经很短了。人类的偷懒的方法是无止境的。Swift中定义了运算符函数 &lt;code&gt;&amp;gt;&lt;/code&gt;, 我们可以把它传递给 sorted 函数。于是乎变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你还想问有没有更偷懒的方法？我只想说，兄台你醒醒吧，都只要输入一个字符而已了，你还要怎么样。。。&lt;/p&gt;
&lt;p&gt;除了上面的一些用法外，还有一种叫做尾随闭包（就是跟在调用它的函数的屁股后面的闭包），当调用它的函数的最后一个参数是闭包时，可以使用。我们可以把&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成尾随闭包形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大概就这些。。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Thu, 26 Mar 2015 15:37:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-03-26:yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</guid><category>Swift</category></item><item><title>如何在Github for Mac/Windows上使用非Github的仓库</title><link>http://blog.shuiguzi.com/ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</link><description>&lt;p&gt;&lt;strong&gt;[2015-08-14 更新]&lt;/strong&gt; 之前的 Github for Windows 和 Github for Mac 已经合并成 Github Desktop 了。下载地址为 &lt;a href="https://desktop.github.com"&gt;https://desktop.github.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你或许跟我一样，不想花太多时间去"精通"git的各种命令，想用简单明了的方法来玩git。而Github的客户端恰是这种良药。使用过的童鞋可能有过跟我一样困惑：Github客户端在界面上只能管理Github的代码仓库，怎么才能管理非Github的仓库呢？&lt;/p&gt;
&lt;p&gt;这个问题也就是本文要解决的内容。先讲Github for Mac, 然后是Github for Windows&lt;/p&gt;
&lt;h3&gt;Github for Mac&lt;/h3&gt;
&lt;p&gt;首先创建一个本地的仓库, 假设取名为&lt;strong&gt;Freekick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_1" src="images/GitClient/mac_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后把git仓库的https地址设置为&lt;strong&gt;Freekick&lt;/strong&gt;仓库的&lt;strong&gt;Primary remote repository&lt;/strong&gt;。在&lt;strong&gt;Settings&lt;/strong&gt;选项卡中设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_2" src="images/GitClient/mac_2.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;上一步完成之后点击&lt;strong&gt;Updae Remote&lt;/strong&gt;按钮，之后会弹出输入账号密码的对话框。输入正确的账号密码即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_3" src="images/GitClient/mac_3.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后切换到&lt;strong&gt;Changes&lt;/strong&gt;选项卡，点击右上角的&lt;strong&gt;publish&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_4" src="images/GitClient/mac_4.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;最后Github for Mac会自动同步仓库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_5" src="images/GitClient/mac_5.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;Github for Windows&lt;/h3&gt;
&lt;p&gt;在Windows上只需要把git仓库的https地址拖拽到Github for Windows客户端上，然后会弹出对话框。输入正确的账号密码后，Github for Windows会自动同步代码。拖拽的时候最好把浏览器窗户缩小，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="windows_1" src="images/GitClient/windows_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;Github客户端不能本地创建新的仓库，然后发布到除Github之外的代码托管服务器上。如果需要新建一个仓库，我们可以先创建好一个空的新仓库，然后再用本文提到的方法来同步仓库来达到目的。&lt;/p&gt;
&lt;p&gt;另外，由于Github客户端是为Github量身定做的，当管理非Github仓库时，会有少量跟github相关的功能不能用。但是个人觉得这个不影响体验。我们可以通过下面的地址在官方下载Github客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github for Windows:&lt;/strong&gt; &lt;a href="https://windows.github.com/"&gt;https://windows.github.com/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Github for Mac:&lt;/strong&gt; &lt;a href="https://mac.github.com/"&gt;https://mac.github.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Fri, 14 Aug 2015 20:00:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-01-28:ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</guid><category>Git</category></item><item><title>从C#到Python</title><link>http://blog.shuiguzi.com/cong-cdao-python.html</link><description>&lt;p&gt;项目组最近可能要用Python写一插件，虽然自己只是会用，但是还是被要求给大家做个简单的Python入门培训。只能冲个胖子，硬着头皮上了。
由于项目组里大部分童鞋们都会C#，可能如果从C#做类比的角度来阐述Python语法会更好点，然后下面奇怪的Python教程出来了。大家可以在这里得到PPT和代码:  &lt;a href="https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start"&gt;https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是讲语法的代码，语法部分在注释中有描述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- encoding:utf-8 -*-&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;本代码主要展示Python的基本数据类型和语法, 及其用法，希望可以帮助大家快速入门。&lt;/span&gt;
&lt;span class="sd"&gt;如果不是C#程序员, 请忽略‘C#伪代码’, 直接通过参考‘Python规则’部分来学习&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;




&lt;span class="c"&gt;# ---------------------------------注释----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 注释&lt;/span&gt;

&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    1. 用#打头表示注释&lt;/span&gt;
&lt;span class="sd"&gt;    2. 用三引号的字符串块，也可以表示注释（因为编译器会忽略3引号的块）&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;



&lt;span class="c"&gt;# -----------------------------------赋值-------------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 赋值&lt;/span&gt;

&lt;span class="sd"&gt;Python规则: &lt;/span&gt;
&lt;span class="sd"&gt;    Python是动态语言，变量类型在赋值阶段决定，不像其他语言一样需要先声明变量的数据类型(如C#).&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码: &lt;/span&gt;
&lt;span class="sd"&gt;    string var_sample = &amp;quot;something&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_sample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;someting&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#变量var_sample是字符串类型&lt;/span&gt;




&lt;span class="c"&gt;# ------------------------------Python基本数据类型-----------------------------------------------&lt;/span&gt;
&lt;span class="c"&gt;#   1. 空, 用None表示。&lt;/span&gt;
&lt;span class="c"&gt;#   2. 布尔类型: &lt;/span&gt;
&lt;span class="c"&gt;#   3. 数值类型。&lt;/span&gt;
&lt;span class="c"&gt;#   4. 字符串&lt;/span&gt;
&lt;span class="c"&gt;#   5. 列表, 也就是数组。&lt;/span&gt;
&lt;span class="c"&gt;#   6. 字典&lt;/span&gt;
&lt;span class="c"&gt;#   7. 集合(set)，无序的，不重复的元素集。&lt;/span&gt;
&lt;span class="c"&gt;#   8. 元组(Tuple), 和列表类似，但是一旦初始化就不能改变。&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 空  -----------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    空类型用None表示, 类似C#中的null.&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T s = null; // T表示可空类型&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_none&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 布尔类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    True和False. 对应C#中的true和false。&lt;/span&gt;
&lt;span class="sd"&gt;    基本类型中空、任何数值类型中的0、空字符串、空元组()、空列表[]、空字典{}都被当作 False.&lt;/span&gt;
&lt;span class="sd"&gt;    布尔运算有3中not, and和or, 他们的优先级是 not &amp;gt; and &amp;gt; or&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool1 = true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool2 = false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool3 = 3 &amp;gt; 2;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool4 = !true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool5 = true &amp;amp;&amp;amp; true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool6 = true || false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool7 = false || ((!false) &amp;amp;&amp;amp; true);&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_bool1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;        &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;    &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# 变量值为 True&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 数值类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    数值类型包括整型(int)和浮点数(float)&lt;/span&gt;
&lt;span class="sd"&gt;    整型前缀0b表示二机制，0O表示八进制，0X表示十六进制&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    int var_int = 1;&lt;/span&gt;
&lt;span class="sd"&gt;    int var_binary = Convert.ToInt32(&amp;quot;0010&amp;quot;, 2);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_octal = Convert.ToInt32(&amp;quot;0010&amp;quot;, 8);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_hex = 0x0010;&lt;/span&gt;
&lt;span class="sd"&gt;    double var_float = 1.0; // 或者 float var_float = 1.0;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;var_binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mb"&gt;0b0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为2&lt;/span&gt;
&lt;span class="n"&gt;var_octal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;O0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为8, 0O第二个是字母O&lt;/span&gt;
&lt;span class="n"&gt;var_hex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为16&lt;/span&gt;
&lt;span class="n"&gt;var_float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 字符串  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字符串有多种表示方法，可以是&lt;/span&gt;
&lt;span class="sd"&gt;    1. 单引号&lt;/span&gt;
&lt;span class="sd"&gt;    2. 双引号&lt;/span&gt;
&lt;span class="sd"&gt;    3. 三引号, 字符串块，如果没有赋值给变量，会被编译器忽略，在这种情况下可以拿来当注释用&lt;/span&gt;

&lt;span class="sd"&gt;    字符串可以带r前缀，表示raw string, 不用转义&lt;/span&gt;
&lt;span class="sd"&gt;    字符串可以带u前缀，表示Unicode编码&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str2 = &amp;quot;some string&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str3 = @&amp;quot;C:\mydir\file.txt&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str4 = @&amp;quot;C:\mydir\文件.txt&amp;quot;; &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;var_str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some string&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;r&amp;quot;C:\mydir\file.txt&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;&amp;quot;&amp;quot;C:\mydir\文件.txt&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;#下面两种字符串格式是等价的&lt;/span&gt;
&lt;span class="n"&gt;var_str_fromat1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;var_str_format2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{0} {1}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 列表  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    列表，即数组, 用[]表示, 可以包含不同类型的元素。 C#中的数组或者List&amp;lt;&amp;gt;与其类似，但是C#必须指明元素数据类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的数组或List&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;  &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;       &lt;span class="c"&gt;# 索引下标从0开始，这段代码把第2位元素赋值为字符串&amp;#39;2&amp;#39;，取代了原来的整型2. 此时var_list值为 [1, &amp;#39;2&amp;#39;, [3]]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 添加一元素，此时var_list值为 [1, &amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 删除一元素，从头遍历，删除第一个元素1, 此时var_list值为 [&amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 继续删除1， 此时var_list值为 [&amp;#39;2&amp;#39;, [3]]&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 字典  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字典，用{}表示，可以用不同的类型做key和value, key和value之间用:号连接&lt;/span&gt;
&lt;span class="sd"&gt;    C#中的Dictionary&amp;lt;&amp;gt;和这个类似，但是C#必须指明Key和Value的类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的Dictionary&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello dictionary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 通过Key访问元素&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c"&gt;# 删除已元素，用del关键词&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 集合  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    集合(set)，是一个无序的，元素不重复的集，元素可以是不同类型。C#中的HashSet&amp;lt;&amp;gt;和这个类似，但是C#中必须指定类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的HashSet&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素, 此时var_set值为 set([1, &amp;#39;2&amp;#39;])&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 元组 -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    元组(Tuple), 用()表示，能包含不同类型元素。 和列表类似，但是一旦初始化就不能改变。C#中的Tuple&amp;lt;&amp;gt;和这个类似&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;   Tuple&amp;lt;int, int&amp;gt; var_tuple = new Tuple&amp;lt;int, int&amp;gt;(10, 20); &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_tuple_item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_tuple&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# 访问item, 下标从0开始&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------循环控制-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    python支持for和while循环&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    for(int i; i &amp;lt; 10; i ++) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        // do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    foeach(var item in List) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    int count = 0;&lt;/span&gt;
&lt;span class="sd"&gt;    while (count &amp;lt; 10)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        count += 1;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;


&lt;span class="c"&gt;# ------------------------------条件判断-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    条件判断 if, if-else, if-elif-else，或者包含多个elif的if-elif-elif...-else, 每个关键词后要带冒号&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    if (3 &amp;gt; 2) {}&lt;/span&gt;

&lt;span class="sd"&gt;    if (3 &amp;lt; 2)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    if ( 3 &amp;lt; 2 )&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 3)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 4)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------异常处理-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    关键词try...excpet&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       int i = 1/0; &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch(ZeroDivisionError)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ZeroDivisionError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------函数-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    函数用def来声明&lt;/span&gt;
&lt;span class="sd"&gt;    没有返回值声明，返回值由函数语句中的return来指明，并且可以有多个返回值。&lt;/span&gt;
&lt;span class="sd"&gt;    参数不需要带类型名字&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以赋值给变量&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以嵌套&lt;/span&gt;

&lt;span class="sd"&gt;    特别关注： 一些函数会用 *args和 **kwargs当作参数来表示可变参数：&lt;/span&gt;
&lt;span class="sd"&gt;        * --  以元组作为参数传入&lt;/span&gt;
&lt;span class="sd"&gt;        ** -- 以字典做为参数传入&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T test_function&amp;lt;T&amp;gt;(T a, T b)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        return a + b;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#的return 没有多返回值，且可变参方法不支持不同类型，这里不提供类比代码&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    按照python的风格，方法的注释用三引号字符块表示，并且方法函数声明与其&lt;/span&gt;
&lt;span class="sd"&gt;    第一行语句中间&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;var_test_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_function&lt;/span&gt; &lt;span class="c"&gt;# 函数可以赋值给变量&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 返回3&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回&amp;#39;12&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多个返回值&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    参数不确定时&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="n"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;上面语句输出为:&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;tuple&amp;#39;&amp;gt; (1, [1, &amp;#39;2&amp;#39;], 2)&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;dict&amp;#39;&amp;gt; {&amp;#39;a&amp;#39;: 3, &amp;#39;b&amp;#39;: [1, 2, 4, 5]}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# ------------------------------面向对象-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则&lt;/span&gt;
&lt;span class="sd"&gt;    类用关键词class表示&lt;/span&gt;
&lt;span class="sd"&gt;    类可以继承，并且支持多继承&lt;/span&gt;
&lt;span class="sd"&gt;    类的构造函数名字是固定的，名字是__init__, init前后是两个下划线&lt;/span&gt;
&lt;span class="sd"&gt;    类的析构函数名字也是固定的，名字是__del__&lt;/span&gt;
&lt;span class="sd"&gt;    实例方法第一参数名字必须是self,用于传递对象本身&lt;/span&gt;
&lt;span class="sd"&gt;    静态方法用@staticmethod装饰器表示，类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;    类方法用@classmethod装饰器表示，类似于C#中的类的静态方法&lt;/span&gt;
&lt;span class="sd"&gt;    子类同名的方法会覆盖父类同名方法&lt;/span&gt;
&lt;span class="sd"&gt;    多继承中，如果不同父类有有相同明名字的字段，则其值为最近一次所赋的值。&lt;/span&gt;

&lt;span class="sd"&gt;c#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    class Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public string msg;&lt;/span&gt;


&lt;span class="sd"&gt;        public Base(string msg)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            this.msg = msg;&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_class()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.Writeline(this.msg);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print something from Base&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    class Child : Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public Child : base(&amp;quot;Child&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;

&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public override void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print someting from Child&amp;quot;);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#不支持类的多继承&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        方法的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;        __init__()是构造函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        析构函数, 一般很少用&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base  {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;print something from Base&amp;#39;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    单继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        与父类同名，会覆盖父类的print_somthing方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print someting from Child&amp;quot;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base2 {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        静态方法, 要带@staticmethod装饰器, 类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;statc methond in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thiscls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        类方法，要带@classmethod装饰器，类似C#中的类的静态方法, 带一个参数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;class_method in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        访问父类方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access static methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access class methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access instance methond in parent class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类测试方法&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="c"&gt;# 多继承时，&lt;/span&gt;
    &lt;span class="c"&gt;#  1. 当不同的父类有相同的字段时, 其值为最近一次所赋的值&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="c"&gt;#  2. 当不同父类有相同方法时, 执行继承列表中的第一个父类的方法&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------模块与包-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    导入模块或包有好几种方式&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入：  import [moudle_name or package_name]&lt;/span&gt;
&lt;span class="sd"&gt;使用时要带上module_name或者package_name&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;module&lt;/span&gt;
&lt;span class="c"&gt;#print module.get_module_name()&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt;
&lt;span class="n"&gt;SamplePackage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addmodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种一： from [moudle_name or package name] import [...]&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;modemodule&lt;/span&gt; 
&lt;span class="n"&gt;modemodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种二： from [moudle_name or package name] import *  &lt;/span&gt;
&lt;span class="sd"&gt;*表示导入所有&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage.multiplymodule&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;__name__ 在默认情况下：&lt;/span&gt;
&lt;span class="sd"&gt;    1. 如果被自己模块内调用，它的值是 __main__&lt;/span&gt;
&lt;span class="sd"&gt;    2. 如果在外部模块调用，他的值是模块名字&lt;/span&gt;

&lt;span class="sd"&gt;所以我们可以把模块内部的测试代码放到下面代码中，不会影响其他模块&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码地址: &lt;a href="https://github.com/wudixiaop/Nana/blob/master/Python/Tutorial/Python%20Quick%20Start/PythonQuickStart/Python_Introduction.py"&gt;Github&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 07 Jan 2015 20:13:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2015-01-07:cong-cdao-python.html</guid><category>Python</category></item><item><title>如何在Visual Studio中愉快的玩耍</title><link>http://blog.shuiguzi.com/ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</link><description>&lt;p&gt;好吧，其实我想要说一些我觉得可以在Visual Studio中提高效率的经验。下面直接进入正题：&lt;/p&gt;
&lt;h3&gt;熟记并使用各种快捷键&lt;/h3&gt;
&lt;p&gt;快捷键之所以叫快捷键就是因为它会让事情变得更快捷。好吧，其实我知道前面一句废话。下面就列举一些碰上常用的(基于Visual C# 2005快捷键映射)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注释: &lt;strong&gt;Ctrl + E, C&lt;/strong&gt; (也就是，先&lt;strong&gt;Ctrl&lt;/strong&gt;和&lt;strong&gt;E&lt;/strong&gt;一起摁，然后摁&lt;strong&gt;C&lt;/strong&gt;. 下面碰到有带组合键的情况类似)&lt;/li&gt;
&lt;li&gt;取消注释: &lt;strong&gt;Ctrl + E, U&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整行剪切: &lt;strong&gt;Ctrl + X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开光标所在行的概述(Outlining): &lt;strong&gt;Ctrl + M, M&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起概述(Outlining)到定义: &lt;strong&gt;Ctrl + M, O&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开所有概述(Outlining): &lt;strong&gt;Ctrl + M, L&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;呼出自动补全窗口: &lt;strong&gt;Ctrl + J&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;回跳到光标上一次所在位置: &lt;strong&gt;Ctrl + -&lt;/strong&gt; (这是减号)&lt;/li&gt;
&lt;li&gt;MSDN帮助: &lt;strong&gt;F1&lt;/strong&gt; (光标移到类名或者方法名上，然后摁&lt;strong&gt;F1&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;运行: &lt;strong&gt;F5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;编译: &lt;strong&gt;F6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;调试时Step Over/In: &lt;strong&gt;F10&lt;/strong&gt;/&lt;strong&gt;F11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跳转到定义: &lt;strong&gt;F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;搜索和替换窗口: &lt;strong&gt;Ctrl + Shift + F&lt;/strong&gt; 或者 &lt;strong&gt;Ctrl + Shift + H&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当然还有超级好用的自能感应: &lt;strong&gt;Ctrl + .&lt;/strong&gt; (或者&lt;strong&gt;Ctrl + Shift + F10&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然还有很多其他快捷，但是平时自己用的少，就不列举了。&lt;/p&gt;
&lt;h3&gt;偷懒技巧一：使用代码片段管理器(Code Snippets Manager)&lt;/h3&gt;
&lt;p&gt;如果还不知道有这个东西的童鞋可以在Vistual Studio的工具菜单中找到。具体怎么用大家可以参照别的童鞋们的文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/cyq1162/archive/2013/06/14/3135373.html"&gt;Visual Studio 小技巧：自定义代码片断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kb.cnblogs.com/page/42164/"&gt;使用Visual Studio Snippet(片断)提交开发效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单一句话描述Code Snippets使用就是：如果用C#举例，编写代码的时候，输入代码片段的快捷键(比如for), 然后摁两下Tab键，接下来就知道怎么做了。&lt;/p&gt;
&lt;p&gt;按惯例，列举一些C#常用的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;循环: &lt;strong&gt;for&lt;/strong&gt;, &lt;strong&gt;foreach&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成类: &lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成构造函数: &lt;strong&gt;ctor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成属性: &lt;strong&gt;prop&lt;/strong&gt;, &lt;strong&gt;propfull&lt;/strong&gt;, &lt;strong&gt;propdp&lt;/strong&gt;(Wpf系列中的依赖属性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;偷懒技巧二: Toolbox&lt;/h3&gt;
&lt;p&gt;文字看多了，咱们来看视频吧&lt;/p&gt;
&lt;iframe src="//channel9.msdn.com/Series/vstips/lazycodesnippets/player?format=html5" allowFullScreen frameBorder="0"&gt;&lt;/iframe&gt;

&lt;p&gt;视频源地址：&lt;a href="http://channel9.msdn.com/Series/vstips/lazycodesnippets"&gt;http://channel9.msdn.com/Series/vstips/lazycodesnippets&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;成为高手~~&lt;/h3&gt;
&lt;p&gt;不想成为标题党的程序员不是一个好写手。好吧，其实我是来推荐&lt;strong&gt;VsVim&lt;/strong&gt;这个插件的。。。&lt;/p&gt;
&lt;p&gt;首先，我们需要安装&lt;strong&gt;VsVim&lt;/strong&gt;。童鞋们可以在VS工具菜单下的扩展及更新(Extension and Updates)里查找并安装。具体可以参照这篇文章: &lt;a href="http://www.tuicool.com/articles/YF7RNv"&gt;http://www.tuicool.com/articles/YF7RNv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后开始练技能打怪练级:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://coolshell.cn/articles/5426.html"&gt;http://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jaredpar/VsVim/wiki/faq"&gt;https://github.com/jaredpar/VsVim/wiki/faq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再然后会慢慢发现平时编码时摸鼠标的次数越来少。。。&lt;/p&gt;
&lt;p&gt;再然后。。。没有再然后了。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 24 Dec 2014 14:50:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-12-24:ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</guid><category>Visual Studio</category></item><item><title>一起看看MonoBehavior内部事件执行顺序</title><link>http://blog.shuiguzi.com/yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html</link><description>&lt;h3&gt;&lt;strong&gt;写在最前面&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;或许对于大部分Unity3D程序员来说，第一次接触脚本编写的时候都是从MonoBehavior开始的。MonoBehavior是Uniy3d脚本编写核心的类之一， 它预先定义好了很多事件，并且这些事件按照预先定义好顺序执行。了解MonoBehavior提供的这些事件的执行顺序，是我们进一步提高脚步编程和了解Unity3D内部逻辑的必要一步。我们先从MonoBehavior提供的事件说起。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;MonoBehavior都提供了什么事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MonoBehavior提供的事件从编辑器到游戏结束都有涉及。下面列举一些常用的，更详列表可以参照&lt;a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html"&gt;这个页面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与编辑相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Reset&lt;/td&gt;
            &lt;td&gt;Reset to default values.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;FixedUpdate&lt;/td&gt;
            &lt;td&gt;This function is called every fixed framerate frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Update&lt;/td&gt;
            &lt;td&gt;Update is called every frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LateUpdate&lt;/td&gt;
            &lt;td&gt;LateUpdate is called every frame, if the Behaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Awake&lt;/td&gt;
            &lt;td&gt;Awake is called when the script instance is being loaded.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnEnable&lt;/td&gt;
            &lt;td&gt;This function is called when the object becomes enabled and active.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDisable&lt;/td&gt;
            &lt;td&gt;This function is called when the behaviour becomes disabled () or inactive.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDestroy&lt;/td&gt;
            &lt;td&gt;This function is called when the MonoBehaviour will be destroyed.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationFocus&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player gets or loses focus.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationPause&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player pauses.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationQuit&lt;/td&gt;
            &lt;td&gt;Sent to all game objects before the application is quit.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Start&lt;/td&gt;
            &lt;td&gt;Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter&lt;/td&gt;
            &lt;td&gt;OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay&lt;/td&gt;
            &lt;td&gt;OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit&lt;/td&gt;
            &lt;td&gt;OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when an incoming collider makes contact with this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where a collider on another object is touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit2D&lt;/td&gt;
            &lt;td&gt;Sent when a collider on another object stops touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter&lt;/td&gt;
            &lt;td&gt;OnTriggerEnter is called when the Collider other enters the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay&lt;/td&gt;
            &lt;td&gt;OnTriggerStay is called once per frame for every Collider other that is touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit&lt;/td&gt;
            &lt;td&gt;OnTriggerExit is called when the Collider other has stopped touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when another object enters a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where another object is within a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit2D&lt;/td&gt;
            &lt;td&gt;Sent when another object leaves a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDown&lt;/td&gt;
            &lt;td&gt;OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseOver&lt;/td&gt;
            &lt;td&gt;OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUp&lt;/td&gt;
            &lt;td&gt;OnMouseUp is called when the user has released the mouse button.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDrag&lt;/td&gt;
            &lt;td&gt;OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseEnter&lt;/td&gt;
            &lt;td&gt;OnMouseEnter is called when the mouse entered the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseExit&lt;/td&gt;
            &lt;td&gt;OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUpAsButton&lt;/td&gt;
            &lt;td&gt;OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渲染相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreCull&lt;/td&gt;
            &lt;td&gt;OnPreCull is called before a camera culls the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameVisible&lt;/td&gt;
            &lt;td&gt;OnBecameVisible is called when the renderer became visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameInvisible&lt;/td&gt;
            &lt;td&gt;OnBecameInvisible is called when the renderer is no longer visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnWillRenderObject&lt;/td&gt;
            &lt;td&gt;OnWillRenderObject is called once for each camera if the object is visible.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreRender&lt;/td&gt;
            &lt;td&gt;OnPreRender is called before a camera starts rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderObject&lt;/td&gt;
            &lt;td&gt;OnRenderObject is called after camera has rendered the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPostRender&lt;/td&gt;
            &lt;td&gt;OnPostRender is called after a camera finished rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderImage&lt;/td&gt;
            &lt;td&gt;OnRenderImage is called after all rendering is complete to render image.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnGUI&lt;/td&gt;
            &lt;td&gt;OnGUI is called for rendering and handling GUI events.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDrawGizmos&lt;/td&gt;
            &lt;td&gt;Implement OnDrawGizmos if you want to draw gizmos that are also pickable and always drawn.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;用图来表示MonoBehavior事件执行顺序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="monobehavior" src="images/monobehaviour_flowchart.svg" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首次加载场景时执行&lt;strong&gt;Awake()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Start()&lt;/strong&gt;只在第一帧才执行, &lt;strong&gt;Start()&lt;/strong&gt;在&lt;strong&gt;Awake()&lt;/strong&gt;之后执行&lt;/li&gt;
&lt;li&gt;Update的执行顺序是: &lt;strong&gt;FixedUpdate()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Update()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;LateUpdate()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以每一帧的&lt;strong&gt;Update()&lt;/strong&gt;事件作分界线：  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Update()之前&lt;/strong&gt;：&lt;strong&gt;物理系统&lt;/strong&gt;和&lt;strong&gt;输入系统&lt;/strong&gt;相关事件先执行，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;和&lt;strong&gt;OnMouseXXX&lt;/strong&gt;事件。此处&lt;strong&gt;XXX&lt;/strong&gt;是占位符，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;可以代表&lt;strong&gt;OnTriggerEnter&lt;/strong&gt;或者&lt;strong&gt;OnTriggerExit&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update()之后&lt;/strong&gt;：&lt;strong&gt;场景渲染&lt;/strong&gt;和&lt;strong&gt;协程&lt;/strong&gt;，如&lt;strong&gt;OnRenderImage()&lt;/strong&gt;和&lt;strong&gt;yield WWW&lt;/strong&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协程中，除了&lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt;是在&lt;strong&gt;FixedUpdate&lt;/strong&gt;之后，&lt;strong&gt;Update&lt;/strong&gt;之前执行，其他的都是在&lt;strong&gt;Update&lt;/strong&gt;之后，&lt;strong&gt;场景渲染&lt;/strong&gt;前执行&lt;/li&gt;
&lt;li&gt;GUI事件&lt;strong&gt;OnGUI&lt;/strong&gt;在场景渲染完之后执行&lt;/li&gt;
&lt;li&gt;当对象被销毁时执行&lt;strong&gt;OnDestory()&lt;/strong&gt;事件&lt;/li&gt;
&lt;li&gt;当游戏退出时执行&lt;strong&gt;OnApplicationQuit()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;和&lt;strong&gt;OnDisable()&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;只有在Object是Active的状态下才能用，一般是Object被初始化或者Object从disable到active过程中被调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnDisable()&lt;/strong&gt;只有到Object从active到disable状态才被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 23 Dec 2014 18:20:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-11-10:yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html</guid><category>Unity</category></item><item><title>关于 Unity 编辑器一些事儿</title><link>http://blog.shuiguzi.com/guan-yu-unity-bian-ji-qi-yi-xie-shi-er.html</link><description>&lt;p&gt;这里描述下Unity3D编辑器使用过程中遇到的坑及其解决方法&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件一：Unity3d编辑器启动时默认打开最近一次打开的项目&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;默认设置中，Unity3D启动时会自动打开默认最近一次打开的项目。每当只想打开小项目，而偏偏上次打开过一个大项目时，这点让人很抓狂。&lt;br /&gt;
&lt;strong&gt;解决方法:&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在编辑器中打开&lt;strong&gt;Unity Preferences&lt;/strong&gt;窗口,通过 &lt;strong&gt;Edit-&amp;gt;Preferences...&lt;/strong&gt;打开&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;General&lt;/strong&gt;选项卡中把&lt;strong&gt;Always Show Project Wizard&lt;/strong&gt;勾选上&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件二：Project Wizard中最近打开项目记录删除不了&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一直不明白为啥不让删除呢？  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法一：让项目地址失效&lt;/strong&gt;  &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;重名名项目文件夹&lt;/li&gt;
&lt;li&gt;把项目移动到别的文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法二：修改注册表&lt;/strong&gt;  &lt;blockquote&gt;
&lt;p&gt;删除 HKEY_CURRENT_USER\Software\Unity Technologies\Unity Editor 4.x 下面以 RecentlyUsedProjectPaths 开头的项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;以后继续补充...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Wed, 05 Nov 2014 22:30:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-11-05:guan-yu-unity-bian-ji-qi-yi-xie-shi-er.html</guid><category>Unity</category></item><item><title>ShaderlabVS Release Page</title><link>http://blog.shuiguzi.com/shaderlabvs-release-page.html</link><description>&lt;h3&gt;&lt;em&gt;Latest Version - V0.6&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;hr&gt;
&lt;strong&gt;[2015-10-17] V0.6 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add VS2015 support&lt;/li&gt;
&lt;li&gt;Improve code completion feature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;IMPROTANT :&lt;/strong&gt; We have to execute &lt;code&gt;vs2015_register.cmd&lt;/code&gt; after extension installed to linke .shader and .cginc files to ShaderlabVS plugin on VS2015. It's not required on VS2013 / VS2012.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download Address:&lt;/strong&gt; &lt;a href="http://pan.baidu.com/s/1jGAjzd8"&gt;http://pan.baidu.com/s/1jGAjzd8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;hr&gt;
&lt;strong&gt;A introduction of ShaderlabVS can be found at &lt;a href="https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md"&gt;https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md&lt;/a&gt;. If you have feedbacks or questions, send email to me. My email is rockylai@qq.com.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;Screenshot&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="preview" src="https://github.com/wudixiaop/ShaderlabVS/raw/master/img/Highlighting.PNG" width="60%"/&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;&lt;em&gt;History:&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-28] V0.5 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add braces matching&lt;/li&gt;
&lt;li&gt;Add outlining&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.5/ShaderlabVS-0.5.zip"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1qW9aR5E"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-19] V0.4 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add support for .cginc and .glslinc file&lt;/li&gt;
&lt;li&gt;Add more keywords support&lt;/li&gt;
&lt;li&gt;Syntax highlighting is case insensitive now&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.4/ShaderlabVS.zip"&gt;Github Relase Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1o6sPOUI"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;V0.3 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support Signature help feature&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.3/ShaderlabVS-0.3.zip"&gt;Github Release page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1eQEJQHO"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 28 Oct 2014 21:20:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-10-28:shaderlabvs-release-page.html</guid><category>Shader</category></item><item><title>Why I start ShaderlabVS</title><link>http://blog.shuiguzi.com/why-i-start-shaderlabvs.html</link><description>&lt;p&gt;Last month, &lt;a href="http://unityvs.com/"&gt;SyntaxTree&lt;/a&gt;, the creator of UnityVS plugin for Visual Studio was acquired by Microsoft. Microsoft have published the UnityVS to Visual Studio users for free at the end of July.&lt;/p&gt;
&lt;p&gt;UnityVS is cool tool that make it's possible to debug Unity scripts in VS. But the tool is not support the Unity shaderlab syntax. it's pain for me to read/write shader in VS, So I created the ShaderlabVS to help myself and may would help someone who need it.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Rocky Lai</dc:creator><pubDate>Tue, 19 Oct 2010 18:09:00 +0800</pubDate><guid>tag:blog.shuiguzi.com,2014-08-31:why-i-start-shaderlabvs.html</guid><category>Shader</category></item></channel></rss>