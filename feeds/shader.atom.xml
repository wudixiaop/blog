<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>心亡则忙，亡心则忘</title><link href="http://blog.shuiguzi.com/" rel="alternate"></link><link href="http://blog.shuiguzi.com/feeds%5Cshader.atom.xml" rel="self"></link><id>http://blog.shuiguzi.com/</id><updated>2015-05-06T16:05:00+08:00</updated><entry><title>瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html" rel="alternate"></link><updated>2015-05-06T16:05:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-05-06:xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html</id><summary type="html">&lt;p&gt;这节的问题: 假设有很多对象需要渲染，而你想自己指定这些对象被渲染的顺序的话应该怎么做？&lt;/p&gt;
&lt;p&gt;先上答案：使用 Subshader 的 Queue 标签指定。&lt;/p&gt;
&lt;p&gt;那 Queue 标签又是是那么？？ 我们继续往下看，先介绍 Subshader 的标签&lt;/p&gt;
&lt;h3&gt;Subshader 的标签&lt;/h3&gt;
&lt;p&gt;在上一节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;初识 Shaderlab&lt;/a&gt; 中我们知道 Subshader 语句块内有个 &lt;code&gt;[Tags]&lt;/code&gt; 可选项，它的作用是是配置渲染引擎应该 &lt;strong&gt;什么时候 和 怎么样&lt;/strong&gt; 去渲染。这就是 Subshader 的标签。&lt;/p&gt;
&lt;p&gt;它的语法是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "TagName1" = "Value1" "TagName2" = "Value2" ... }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是 Tags 语法块内带有若干键值对项（理论上可有很多很多个这种键值对）。可以填写的些键值对可以参考 &lt;a href="http://docs.unity3d.com/Manual/SL-SubshaderTags.html"&gt;这个页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要注意一点 &lt;strong&gt;它只能写在 Subshader 语句块里面，不能写在 Pass 语句块里面&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;Queue 标签&lt;/h3&gt;
&lt;p&gt;Queue 标签是上面提到的可选键值对项中的一个，也就是决定对象被渲染顺序的标签。根据上面的语法，我们可以这么写：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "Queue" = "XXXX" }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的 &lt;code&gt;XXXX&lt;/code&gt; 是 Queue 标签的值，这个值在内部是整数型的索引。&lt;strong&gt;数值越小，越先被渲染&lt;/strong&gt;。但是不要以为直接填整数就可以，Shaderlab 不支持直接填数值，而是先定义好了 5 个具有描述性的词来代替单调的数值。他们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Background：&lt;/strong&gt; 对应数值为 1000，用于需要被最先渲染的对象，如背景什么的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geometry：&lt;/strong&gt; 对应数值为 2000, 用于不透明的物体。这个是默认的选项（如果不指明 Queue 标签的值，自动给你指定为 Geometry）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AlphaTest：&lt;/strong&gt; 对应的数值为 2450, 用于需要使用 AlphaTest 的对象来提高性能。AlphaTest 类似于裁剪(clip) 功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transparent：&lt;/strong&gt; 对应的数值为 3000， 用于需要使用 alpha blending 的对象，比如粒子，玻璃等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Overlay：&lt;/strong&gt; 对应的数值为 4000，用于最后被渲染的对象，比如　UI。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;渲染顺序的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="queue" src="images/Shader/7/queue.png" width="73%" /&gt;&lt;/p&gt;
&lt;p&gt;前面提到虽然 Queue 内部是整型数值，但是写 shader 的时候不能给它指定整型数值，那要是前置给它指定为整型数值会怎么样？？&lt;/p&gt;
&lt;p&gt;答案是：会被忽略，使用默认的值，也就是 Geometry。同样的，随便填写的如 dfadfadf 等值也是会被忽略使用默认值。&lt;/p&gt;
&lt;p&gt;还有 Shaderlab 还对上面五类做了延伸，让他们 &lt;strong&gt;支持加减法&lt;/strong&gt;。比如想让对象在 Background 之后 Geometry 之前渲染，我们可以这么写:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tags { "Queue" = "Geometry-1"}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里有几点比较重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Geometry-1&lt;/code&gt; 中间不能有空格&lt;/li&gt;
&lt;li&gt;这个语法是整型数值的加减法。 &lt;code&gt;Geometry-1&lt;/code&gt; 和 &lt;code&gt;Background+999&lt;/code&gt; 得到的结果是一样的，因为 2000 - 1 = 1000 + 999。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在 Unity3D 编辑器里面选中 shader 文件，然后从 Inspector 里查看 Shader 的 Render queue 属性值，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="render queue" src="images/Shader/7/geometry_1.png" width="60%" /&gt;&lt;/p&gt;
&lt;p&gt;最后基于上一节 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;初识 Shaderlab&lt;/a&gt; 中的精简骨架，我们来写一个伪代码，看看插入 Queue 标签后的样子。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

  &lt;span class="n"&gt;SubShader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Tags&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Queue&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Transparent&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之六：初识 Shaderlab</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html" rel="alternate"></link><updated>2015-05-05T17:55:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-05-05:xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html</id><summary type="html">&lt;p&gt;好吧，其实这不算初识 Shaderlab 了，因为在 &lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;shaderlab 土地上的语言们&lt;/a&gt; 这节中已经说到在 shaderlab 中有三种方式来写 shader。
这节的内容主要是来认识下 shaderlab 语法写出来的 shader 长得什么样子。&lt;/p&gt;
&lt;p&gt;下面有段基于 shaderlab 的 shader 的大概框架的伪代码，在之前要解释下代码中带中括号的部分，如 &lt;code&gt;[Properties]&lt;/code&gt;, 表示是可以选择的，也就是说可以不写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//shader 的名字会显示在 Unity3D 的 Inspector 中选择 shader 的菜单里面&lt;/span&gt;
&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 属性&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Properties&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 可能存在多个 subshader。Unity 会在所有 subshader 列表中选择当前环境中可用的第一个 subshader&lt;/span&gt;
    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// subshader 的标签&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 给多个 pass 公用的设置&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Common&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="c1"&gt;// 可能存在多个 pass, 每个 pass 都会引起一次渲染过程&lt;/span&gt;
        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// pass 的标签&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 渲染设置, 如颜色混合&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Render&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

            &lt;span class="c1"&gt;// 纹理设置，只有在 fixed function shader 中才可用&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Texture&lt;/span&gt; &lt;span class="n"&gt;Setup&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;// 可以有多个 pass&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Pass&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 可以有多个 subshader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;其他的&lt;/span&gt; &lt;span class="n"&gt;Subshader&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当所有 subshader 失败的时候, 使用 Fallback 指定的 shader&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Fallback&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;// 当有自定义 shader 的设置 UI 时候用&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CustomEditor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面伪代码中的注释解释了各个部分的作用，如果去除可选部分，最后就留下&lt;strong&gt;精简的骨架&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;shader 的名字&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;Subshader&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="n"&gt;Pass&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而大部分 shader 都是在上面代码基础上扩展的。&lt;/p&gt;
&lt;p&gt;这节就到这里，会在后面的章节继续聊 shaderlab。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之五：RGBA 101</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html" rel="alternate"></link><updated>2015-05-04T13:55:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-05-04:xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html</id><summary type="html">&lt;p&gt;这节说说 fragment shader 最后输出的像素的颜色表示方法 RGBA。&lt;/p&gt;
&lt;p&gt;玩过 Photoshop 的同学可能知道，存在好几种颜色模式来表示颜色，&lt;a href="http://baike.baidu.com/view/1139658.htm"&gt;比如 RGB 和 CMYK&lt;/a&gt;. 由于显示器的发光物体，所以使用的 RGB 模式。
Unity3D 中也采用这种表示方法。&lt;/p&gt;
&lt;h3&gt;RGB模式&lt;/h3&gt;
&lt;p&gt;RGB是用红绿蓝混合来表示的颜色。R 是红色， G 表示绿色， B 是蓝色。一般用8为来表示一个颜色通道，每个通道有 256 个等级（0~255）。它有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(0, 0, 0)&lt;/code&gt; 表示黑色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(255, 255, 255)&lt;/code&gt; 表示白色&lt;/li&gt;
&lt;li&gt;三个通道数值相同的时候是灰色，比如 &lt;code&gt;(128, 128, 128)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数值越大颜色越亮，反之数值越小越暗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="RGB" src="images/Shader/5/rgb.png" width="61%" /&gt;&lt;/p&gt;
&lt;p&gt;但是 Unity Shader 中并不用 256 个等级来表示颜色数值，而是用标准化（取值0~1）的数值来表示。换句话说就是所有通道都除以 255 得到标准化的结果。&lt;/p&gt;
&lt;h3&gt;RGBA 中的 A 是什么&lt;/h3&gt;
&lt;p&gt;A 叫做 alpha，其数值表示不透明度。 据说提出者用 alpha 来命名源于经典的线性插值方程 αA + (1-α)B 所用的希腊字母 α。Unity3D 中的 aplha blending 基于这个线性方程。&lt;/p&gt;
&lt;h3&gt;混合模式&lt;/h3&gt;
&lt;p&gt;抽象一下就是对两个颜色做运算后得到结果颜色的过程。这个过程其实就是个运算公式。下面列举两个 Photoshop 中常见的正片叠底和滤色两个混合模式的计算公式。C为结果色，A 和 B 是需要混合的颜色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正片叠底(Multiply):&lt;/strong&gt; C=A*B&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滤色(Screen):&lt;/strong&gt; C=1-(1-A)*(1-B)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们要叠加模型多个贴图（比如法线贴图和模型贴图）的时候就可以利用到混合模式。更多混合模式公式参考&lt;a href="http://wenku.baidu.com/view/da9d22d9ad51f01dc281f1f9.html"&gt;这个文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之四：坐标系</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html" rel="alternate"></link><updated>2015-04-30T13:55:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-30:xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html</id><summary type="html">&lt;p&gt;这节从很平常一段对话开始：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲跟乙说：&lt;/strong&gt; 喂，你看到那个人没有？&lt;br /&gt;
&lt;strong&gt;乙：&lt;/strong&gt; 你说的是哪个？&lt;br /&gt;
&lt;strong&gt;甲：&lt;/strong&gt; 就是那棵树旁边那个。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从对话里面我们知道：&lt;strong&gt;要描述一个物体的位置，我们需要借助参照物。&lt;/strong&gt; 其实甲也可以这么说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;甲：&lt;/strong&gt; 在那个个子很高的人左手边那位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以说 &lt;strong&gt;参照物是可以选择的，可变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们把上面对话推广到坐标系上，来给坐标系下个山寨的定义：&lt;strong&gt;坐标系是为了描述物体位置而存在，我们借助的参照物是它的原点
。由于可以选择不同的参照物，所以我们可以选择不同的原点。&lt;/strong&gt; 原点很重要，我们利用坐标系的时候首先要知道原点在哪里。&lt;/p&gt;
&lt;p&gt;既然原点可以任意选，那不是说会出现很多坐标系？ 是的，但是我们使用几种约定的坐标系就好了。&lt;/p&gt;
&lt;h3&gt;那些坐标系们&lt;/h3&gt;
&lt;p&gt;下面是我们平时会碰到的一些坐标系。按规定，原点的各个轴是数值都是 0 来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;物体坐标系 (Object Space)：&lt;/strong&gt; 有时也叫做 Local Space。是 3D 模型内部的坐标系，原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 一般是模型中心。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;世界坐标系 (World Space)：&lt;/strong&gt; Unity3D 系统中的绝对坐标系，原点是在场景的 &lt;code&gt;(0，0，0)&lt;/code&gt; 位置处。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视口坐标系 (Viewport Space)：&lt;/strong&gt; 以摄像机为原点，朝向为 Z 轴的坐标系。原点 &lt;code&gt;(0, 0, 0)&lt;/code&gt; 是摄像机的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;屏幕坐标系 (Screen Space)：&lt;/strong&gt; 原点 &lt;code&gt;(0, 0)&lt;/code&gt; 在屏幕的左下角，右上角为 &lt;code&gt;(Screen.width，Screen.height)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那问题来了。这些坐标系们有什么关系？&lt;/p&gt;
&lt;p&gt;我们以立方体为例。我们从&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;小节中知道，Mesh Renderer 组件得到模型数据之后它会执行 vertex shader（Unity3d 默认的 Shader 给我提供了）。
vertex shader 里面做了下面这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先把立方体从模型的物体坐标系转换成世界坐标系，&lt;strong&gt;从 物体 到 世界&lt;/strong&gt;。这样子，它和摄像机（世界坐标）的位置就用同一个坐标系描述了。&lt;/li&gt;
&lt;li&gt;再把立方体从世界坐标转换成视口坐标系，也就是摄像机因为原点的坐标系，&lt;strong&gt;从 世界 到 视口&lt;/strong&gt;。这样它是在摄像机的正面，还是在反面了。&lt;/li&gt;
&lt;li&gt;最后在投射到屏幕坐标系上， &lt;strong&gt;从 视口 到 屏幕&lt;/strong&gt;。这样知道哪些区域需要绘制在屏幕上，哪些不需要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结上面一系列变换关系就是： &lt;strong&gt;物体 到 世界 再到 视口 再到 屏幕&lt;/strong&gt;。中间经过了三次变换 (transform)。这些变换在数学上通过 &lt;strong&gt;矩阵&lt;/strong&gt; 来描述的。这里有个知识点：
矩阵可以表示变换。在这里推荐关于 3D 数学的一本经典好书 &lt;a href="http://pan.baidu.com/s/1eQ8eSYQ"&gt;《3D数学基础图形与游戏开发》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;到现在是不是有种跃跃欲试，但是想想又头大的感觉，在 Unity3D 里面这些矩阵具体的数值是什么？要是自己去运算那多复杂啊。别急，Unity3D 给我们已经提供了这些矩阵当作 Shader
的内置变量（&lt;a href="http://docs.unity3d.com/Manual/SL-UnityShaderVariables.html"&gt;详情参考这个链接&lt;/a&gt;），可以在编程的时候直接使用。在这里只是说一下，我们利用 &lt;code&gt;UNITY_MATRIX_MVP&lt;/code&gt;
 这个矩阵就可以达到变换到屏幕坐标系的目的。至于怎么做，会在以后的文章中会提到。&lt;/p&gt;
&lt;h3&gt;左手和右手坐标系&lt;/h3&gt;
&lt;p&gt;这两不是新坐标系，是建立三维坐标系的两种选择。换句话说对于处于同一个物体，可以用基于左手坐标系规则来建立三维坐标系，也可以用基于右手坐标系规则来建立三维空间，他们的区别是坐标轴的数值会有差异。&lt;/p&gt;
&lt;p&gt;为什么叫做左手和右手，看看下面的图就知道了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="leftAndright" src="images/Shader/4/leftandRightHandCoordinate.png" width="80%" /&gt;&lt;/p&gt;
&lt;p&gt;一般情况下左手和右手坐标系的数值做转换的话只需把 Z 值乘以 -1 即可。比如左手坐标系的 &lt;code&gt;(1, 1, 1)&lt;/code&gt; 转成为右手坐标系是  &lt;code&gt;(1, 1, -1)&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html" rel="alternate"></link><updated>2015-05-04T14:33:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-29:xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html</id><summary type="html">&lt;p&gt;这节是关于 Unity3D 平台上 shader 语言的选择。&lt;/p&gt;
&lt;p&gt;计算机行业的各公司（或者组织）似乎都遵循着某种规则。当他们在某个领域划出了一亩三分地，当上了地主后, 就要用方法圈住干活的农民。让他们觉得在我这里不会饿死，有饭吃，你要到别家
干活的话，需要重头再来，这是一个很亏本的买卖。这个方法就是制定自己体系（软硬件中的各种协议，接口，语言，框架），脱离这套体系，在别的地方玩不起来。开个玩笑来取名这个规矩叫做&lt;strong&gt;圈地规则&lt;/strong&gt;吧。&lt;/p&gt;
&lt;h3&gt;Shader 语言们&lt;/h3&gt;
&lt;p&gt;根据上面提到的圈地规则，下面来隆重的介绍下 shader 这块地上地主们建立起来的体系：CG, HLSL 和 GLSL 语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CG：&lt;/strong&gt; C for Graphics 的简称，是 NVIDIA 公司开发的语言。从名字上来看的出它是 C 语言的亲戚，现实是它保留了 C 语言的大部分语义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HLSL：&lt;/strong&gt; High Level Shader Language 的简称，由微软开发的语言。语法跟 CG 非常的相似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GLSL：&lt;/strong&gt; OpenGL Shading Language 的简称，OPENGL 组件开发的，语法也是基于 C 语言的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么问题来了，Shader 语言到底哪家强？这个也发生过强烈的讨论。&lt;/p&gt;
&lt;p&gt;其实这个问题好回答，既然跟着 Unity3D 地主干，听 Unity3D 地主的话就好了。那么另外一个问题又来了，Unity3D 地主的观点又是什么？&lt;/p&gt;
&lt;h3&gt;Unity3D 体系规则 Shaderlab&lt;/h3&gt;
&lt;p&gt;根据圈地规则，Unity3D 地主也有自己的体系，那就是 Shaderlab。那 shaderlab 又是什么呢？ 这是一个能包容 CG, HLSL 和 GLSL，并且有自己语法体系的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能包容 CG, HLSL, 和 GLSL 意思是说在它里面能使用这三种语言。Shaderlab 中用特定的语法块来指定他们：&lt;ul&gt;
&lt;li&gt;GG 和 HLSL 包括在 &lt;code&gt;CGPROGRAM ... ENDCG&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;li&gt;GLSL 包括在 &lt;code&gt;GLSLPROGRAM ... ENDGLSL&lt;/code&gt; 语法块内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有自己的语法系统是指它有自己独特的语法，并且独立于上面三种语言（这句似乎是废话。。。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unity3D 官方比较提倡 CG 或 HLSL 语言。所以我们首选这两个中的其中一个了。之前提到，其实这两语法非常相似，所以其实学好了其中一门就差不多等于学了两门语言。（好像很划算的样子！）&lt;/p&gt;
&lt;h3&gt;在 Shaderlab 中写 Shader 的三种方式&lt;/h3&gt;
&lt;p&gt;Unity3D 手册 Shader 参考章节&lt;a href="http://docs.unity3d.com/Manual/SL-Reference.html"&gt;开篇&lt;/a&gt;就写道 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shaders in Unity can be written in one of three different ways:&lt;/p&gt;
&lt;p&gt;as &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;&lt;strong&gt;surface shaders&lt;/strong&gt;&lt;/a&gt;,&lt;br /&gt;
as &lt;a href="http://docs.unity3d.com/Manual/SL-ShaderPrograms.html"&gt;&lt;strong&gt;vertex and fragment shaders&lt;/strong&gt;&lt;/a&gt; or&lt;br /&gt;
as fixed function shaders.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说有三种 shader 的变体。&lt;/p&gt;
&lt;h4&gt;Fixed function shaders&lt;/h4&gt;
&lt;p&gt;这种 shader 一般用于不支持可编程 shader 模型的老设备上面， 比如 iPhone3。Unity3d 用 shaderlab 的语法来配置。&lt;/p&gt;
&lt;h4&gt;vertex and fragment shaders&lt;/h4&gt;
&lt;p&gt;参考名字，这个主要是玩转 vertex 和 fragment shader 的。参考&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;渲染管线&lt;/a&gt;章节可以知道这两个 shader 处于什么位置。&lt;/p&gt;
&lt;h4&gt;surface shaders&lt;/h4&gt;
&lt;p&gt;Unity3d 提倡如果想写跟光线交互的 shader 使用这种方式写。那 surface shader 又是什么。 &lt;a href="http://docs.unity3d.com/Manual/SL-SurfaceShaders.html"&gt;Unity 手册里面有段话道出了真相：&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Surface Shader compiler then figures out what inputs are needed, what outputs are filled and so on, &lt;strong&gt; and generates actual vertex&amp;amp;pixel shaders,&lt;/strong&gt;
as well as rendering passes to handle forward and deferred rendering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原来 surface shader 最终会被编译成 vertex&amp;amp;fragment shader，这只是换了个汤。当然汤里家里点佐料就是 Unity 帮你处理光线而不用自己写算法。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;Unity3D Shaderlab 是基于shader语言上建立了自己的一套语法规则，我们不仅要学习 shaderlab 语法，也要学习 shader 语言。Unity3D 官方提倡使用 CG 或 HLSL 语言。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.unity3d.com/Manual/ShadersOverview.html"&gt;Unity3d Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1rsaho"&gt;GPU 编程与CG 语言之阳春白雪下里巴人&lt;/a&gt;（点击链接即可下载），推荐此书。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之二：渲染管线</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html" rel="alternate"></link><updated>2015-04-28T14:07:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-28:xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html</id><summary type="html">&lt;p&gt;这节描述的是图形渲染的大致过程。&lt;/p&gt;
&lt;p&gt;为了更好理解和记忆这节内容，先来学下面几个词。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;渲染管线(Rendering Pipeline)：&lt;/strong&gt; 一提到管线，感觉很高大上的样子。说的俗一点就是可以理解为流水线。渲染管线我们可暂时理解为 &lt;strong&gt;从得到模型数据到绘制出图像&lt;/strong&gt; 这一过程的称呼。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vertex Shader：&lt;/strong&gt; 对顶点数据编程的一段程序。 人类有懒惰的天性，习惯用简化的词汇来表达同一个东西。对 Vertex Shader 也不例外，一般称其为 VS ，但是在本系列文章中会保持全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fragment Shader：&lt;/strong&gt; 对像素数据编程的一段程序。这里 fragment 可以理解为带有信息（颜色，坐标等）的像素 (Pixel), 一般也简称其为 FS 或者 PS 。 在本系列文章中会保持其全称。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FrameBuffer：&lt;/strong&gt; 缓存帧数据的存储区，它一般包含的是要显示到显示设备上的位图数据（也就是图片数据）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fixed Function：&lt;/strong&gt; 由于一些硬件支持等历史原因，早期的图形 API  &lt;strong&gt;只支持对 GPU 做配置&lt;/strong&gt;，这部分只可配置的功能就是 fixed fucntion。
这里注意下，fixed function 的功能只能配置，不像 Vertex Shader　和 fragment Shader 可以编程（写自己的算法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染管线 (Rendering Pipeline)&lt;/h3&gt;
&lt;p&gt;看图说话&lt;/p&gt;
&lt;p&gt;&lt;img alt="2.renderingpipeline.jpg" src="images/Shader/2/rendering-pipeline.jpg" width="100%" /&gt;&lt;/p&gt;
&lt;p&gt;上面是可编程的渲染管线模型的示意。下面多说几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入阶段。Unity3D 使用 Mesh Renderer 等组件读取模型顶点数据，然后调用图形 API，将数据传递给 GPU。&lt;/li&gt;
&lt;li&gt;现实中同时会进行多条渲染管线，他们是&lt;strong&gt;并行的&lt;/strong&gt;。 这点概念比较重要，以后还会提到它。我们记住 GPU 并行能力很强。&lt;/li&gt;
&lt;li&gt;最后输出的 FrameBuffer (可以理解为渲染出来的图片) 有几率被抛弃掉，也就是说不显示在显示设备上。这个以后单独说明原因。好比残酷的现实世界，努力了（整个渲染过程）也不一定会成功（被显示出来）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;渲染管道是从得模型数据到图像生成过程的一种描述。Vertex Shader 能对顶点数据写处理算法，而 Fragment Shader 能对像素数据写处理算法。&lt;/p&gt;
&lt;h3&gt;参考：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikibooks.org/wiki/Cg_Programming/Programmable_Graphics_Pipeline"&gt;Cg Programming in Unity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Fixed-function"&gt;Fixed-function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html" rel="alternate"></link><updated>2015-04-27T15:54:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-26:xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</id><summary type="html">&lt;p&gt;我想首先唠叨下我为什么打算写这一系列的文章及文章的定位。&lt;/p&gt;
&lt;p&gt;我写的动力主要来源于如下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对之前学习的一些总结、复习和提炼&lt;/li&gt;
&lt;li&gt;尽可能的填充一些概念上的空白。 有不少关于 Unity3D shader 的文章只讲 Shaderlab 语法，讲各种光照模型等, 这对于缺乏概念的新手来说是不太好理解的。&lt;/li&gt;
&lt;li&gt;之前信誓旦旦的跟朋友说以后学了 shader 会写点文章出来，算是允诺。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章定位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是学习笔记，不是教程。如果内容会有出入，非常感谢和希望您能指正。&lt;/li&gt;
&lt;li&gt;主要基础概念为主，可能很零散。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前有前辈说过，学习一门知识前，了解其由来对入门很有好处。我比较赞同这个观点，所以开篇我们来说写历史。&lt;/p&gt;
&lt;h3&gt;CPU 之外的另外一个 PU - GPU&lt;/h3&gt;
&lt;p&gt;随着计算机处理图形的计算量越来越来大，CPU难以满足计算速度上的需求, 为了将图形的计算单独拿出来执行，上世纪70年代开始出现了为加速图形绘制的硬件。
这些硬件跟大部分刚出来的新事物一样，功能有限，而且不太完善，当然那个时候也不叫 GPU。&lt;/p&gt;
&lt;p&gt;1999 年，NVIDIA 公司发布了 GeForce256, 并且提出一个 Graphics Process Unit (GPU) 概念。很多文章都提到这款显卡有划时代的意义，因为它使第一款
带有可编程顶点处理能力的显卡，这意味着显卡从&lt;strong&gt;之前的只可配置&lt;/strong&gt;上升到了&lt;strong&gt;可编程&lt;/strong&gt;的高度，开发者从此可以实现自己顶点处理算法。NVIDIA 也是提出 GPU 这个词
来对 GeForece256 与之前显卡做区分。&lt;/p&gt;
&lt;p&gt;2000 年以后， GPU 技术一直在不断的发展，处理和运算能力不断打变强变大。为了利用 GPU 强大的并行计算能力，出现了 CUDA 并行计算平台。有兴趣的同学可以关注下
&lt;a href="https://developer.nvidia.com/cuda-zone"&gt;CUDA官网&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Shader Model&lt;/h3&gt;
&lt;p&gt;首先我们要提下当今跟 GPU 打交道的形API：&lt;a href="http://en.wikipedia.org/wiki/DirectX"&gt;Microsoft DirectX&lt;/a&gt;、 &lt;a href="https://www.opengl.org"&gt;OPENGL&lt;/a&gt; 和
 转为嵌入式设备设计的&lt;a href="https://www.khronos.org/opengles/"&gt;OPENGL GS&lt;/a&gt;。Directx 是微软提供的图形 API, OPENGL 和 OPENGL ES 现在是由 &lt;a href="http://baike.baidu.com/link?url=vW0PfmVKQC00WWRibyVSrnjRYVdVj1lk9HG6B4w9uc9lnlnWnYoDJd1puZu1CNf2_vacBBTFFbdMzZWCNkliSK"&gt;Khronos Group&lt;/a&gt; 团队维护开发的图形API。&lt;/p&gt;
&lt;p&gt;这些图形 API 都提供对 GPU 编程的能力，这能力就是我们说的 Shader。图形 API 的更新会提供不同的 shader 的能力 (当然是越来越强大)。
微软提出了一个词叫 Shader Model, 并用不同的版本号来区分 Shader 的能力。通常我们也会称 Shader Model 为 SM。&lt;/p&gt;
&lt;p&gt;下面列出到现在为止 Shader Model 的各个版本与 DirectX 版本的对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shader Model 1.0（DirectX8.0）&lt;/li&gt;
&lt;li&gt;Shader Model 2.0（DirectX9.0b）&lt;/li&gt;
&lt;li&gt;Shader Model 3.0（DirectX9.0c）&lt;/li&gt;
&lt;li&gt;Shader Model 4.0（DirectX10）&lt;/li&gt;
&lt;li&gt;Shader Model 4.1（DirectX10.1）&lt;/li&gt;
&lt;li&gt;Shader Model 5.0（DirectX11）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先不关注各个版本区别，只要知道版本号越高，提供的功能越来越强大。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;GPU 为大量图形计算而生，而 Shader 是对 GPU 编程的技术。微软用 Shader Model 的不同版本号来区分不同 Shader 的能力。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphics_processing_unit"&gt;Wikipidia: Graphics processing unit &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/gp/product/1568814240?tag=realtimerenderin&amp;amp;pldnSite=1"&gt;&lt;em&gt;Real-Time Rendering, Third Edition&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/link?url=DDy0sTi56RE9TiVdj5MOCqwmV7ATJEkBHQp7V8eRzA_lyq1HPOLgmBULeSo-Khw2-mb7Wst75LJF3_I3SjZAZa"&gt;Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-er-xuan-ran-guan-xian.html"&gt;瞎聊 Unity3D Shader 系列之二：渲染管线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-san-shader-tu-di-shang-de-yu-yan-men.html"&gt;瞎聊 Unity3D Shader 系列之三：Shader 土地上的语言们&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-si-zuo-biao-xi.html"&gt;瞎聊 Unity3D Shader 系列之四：坐标系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-wu-rgba-101.html"&gt;瞎聊 Unity3D Shader 系列之五：RGBA 101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-liu-chu-shi-shaderlab.html"&gt;瞎聊 Unity3D Shader 系列之六：初识 Shaderlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-qi-jiu-jing-shui-xian-bei-xuan-ran.html"&gt;瞎聊 Unity3D Shader 系列之七：究竟谁先被渲染？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>ShaderlabVS Release Page</title><link href="http://blog.shuiguzi.com/shaderlabvs-release-page.html" rel="alternate"></link><updated>2014-10-28T21:20:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-10-28:shaderlabvs-release-page.html</id><summary type="html">&lt;h2&gt;&lt;em&gt;Latest Version - V0.5&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-28] V0.5 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add braces matching&lt;/li&gt;
&lt;li&gt;Add outlining&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.5/ShaderlabVS-0.5.zip"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1qW9aR5E"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;A introduction of ShaderlabVS can be found at &lt;a href="https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md"&gt;https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md&lt;/a&gt;. If you have feedbacks or questions, send email to me. My email is rockylai@qq.com.&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;&lt;em&gt;Screenshot&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="preview" src="https://github.com/wudixiaop/ShaderlabVS/raw/master/img/Highlighting.PNG" width="100%"/&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;em&gt;History:&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-19] V0.4 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add support for .cginc and .glslinc file&lt;/li&gt;
&lt;li&gt;Add more keywords support&lt;/li&gt;
&lt;li&gt;Syntax highlighting is case insensitive now&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.4/ShaderlabVS.zip"&gt;Github Relase Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1o6sPOUI"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;V0.3 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support Signature help feature&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.3/ShaderlabVS-0.3.zip"&gt;Github Release page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1eQEJQHO"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary><category term="Shader"></category></entry><entry><title>Why I start ShaderlabVS</title><link href="http://blog.shuiguzi.com/why-i-start-shaderlabvs.html" rel="alternate"></link><updated>2010-10-19T18:09:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-08-31:why-i-start-shaderlabvs.html</id><summary type="html">&lt;p&gt;Last month, &lt;a href="http://unityvs.com/"&gt;SyntaxTree&lt;/a&gt;, the creator of UnityVS plugin for Visual Studio was acquired by Microsoft. Microsoft have published the UnityVS to Visual Studio users for free at the end of July.&lt;/p&gt;
&lt;p&gt;UnityVS is cool tool that make it's possible to debug Unity3D scripts in VS. But the tool is not support the Unity3D shaderlab syntax. it's pain for me to to read/write shader in VS, So I created the ShaderlabVS to help myself and may would help someone who need it.&lt;/p&gt;</summary><category term="Shader"></category></entry></feed>