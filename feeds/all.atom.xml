<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>心亡则忙，亡心则忘</title><link href="http://blog.shuiguzi.com/" rel="alternate"></link><link href="http://blog.shuiguzi.com/feeds%5Call.atom.xml" rel="self"></link><id>http://blog.shuiguzi.com/</id><updated>2015-04-26T16:50:00+08:00</updated><entry><title>瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model</title><link href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html" rel="alternate"></link><updated>2015-04-26T16:50:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-26:xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html</id><summary type="html">&lt;p&gt;我想首先唠叨下我为什么打算写这一系列的文章及文章的定位。&lt;/p&gt;
&lt;p&gt;我写的动力主要来源于如下原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对之前学习的一些总结、复习和提炼&lt;/li&gt;
&lt;li&gt;尽可能的填充一些概念上的空白。 有不少关于 Unity3D shader 的文章只讲 Shaderlab 语法，讲各种光照模型等, 这对于缺乏概念的新手来说是不太好理解的。&lt;/li&gt;
&lt;li&gt;之前信誓旦旦的跟朋友说以后学了 shader 会写点文章出来，算是允诺。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文章定位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是学习笔记，不是教程。如果内容会有出入，非常感谢和希望您能指正。&lt;/li&gt;
&lt;li&gt;主要基础概念为主，可能很零散。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前有前辈说过，学习一门知识前，了解其由来对入门很有好处。我比较赞同这个观点，所以开篇我们来说写历史。&lt;/p&gt;
&lt;h3&gt;CPU 之外的另外一个 PU - GPU&lt;/h3&gt;
&lt;p&gt;随着计算机处理图形的计算量越来越来大，CPU难以满足计算速度上的需求, 为了将图形的计算单独拿出来执行，上世纪70年代开始出现了为加速图形绘制的硬件。
这些硬件跟大部分刚出来的新事物一样，功能有限，而且不太完善，当然那个时候也不叫 GPU。&lt;/p&gt;
&lt;p&gt;1999 年，NVIDIA 公司发布了 GeForce256, 并且提出一个 Graphics Process Unit (GPU) 概念。很多文章都提到这款显卡有划时代的意义，因为它使第一款
带有可编程顶点处理能力的显卡，这意味着显卡从&lt;strong&gt;之前的只可配置&lt;/strong&gt;上升到了&lt;strong&gt;可编程&lt;/strong&gt;的高度，开发者从此可以实现自己顶点处理算法。NVIDIA 也是提出 GPU 这个词
来对 GeForece256 与之前显卡做区分。&lt;/p&gt;
&lt;p&gt;2000 年以后， GPU 技术一直在不断的发展，处理和运算能力不断打变强变大。为了利用 GPU 强大的并行计算能力，出现了 CUDA 并行计算平台。有兴趣的同学可以关注下
&lt;a href="https://developer.nvidia.com/cuda-zone"&gt;CUDA官网&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Shader Model&lt;/h3&gt;
&lt;p&gt;首先我们要提下当今跟 GPU 打交道的两大图形API：&lt;a href="http://en.wikipedia.org/wiki/DirectX"&gt;Microsoft DirectX&lt;/a&gt; 和 &lt;a href="https://www.opengl.org"&gt;OPENGL&lt;/a&gt;。
Directx 是微软提供的图形 API, OPENGL 现在是由 &lt;a href="http://baike.baidu.com/link?url=vW0PfmVKQC00WWRibyVSrnjRYVdVj1lk9HG6B4w9uc9lnlnWnYoDJd1puZu1CNf2_vacBBTFFbdMzZWCNkliSK"&gt;Khronos Group&lt;/a&gt; 团队维护开发的图形API。&lt;/p&gt;
&lt;p&gt;DirectX 和 OPENGL 都提供对 GPU 编程的能力，这就是我们说的 Shader。图形 API 的更新会提供不同的 shader 的能力 (当然是越来越强大)。
微软提出了一个词叫 Shader Model, 并用不同的版本号来区分 Shader 的能力。通常我们也会称 Shader Model 为 SM。&lt;/p&gt;
&lt;p&gt;下面列出到现在为止 Shader Model 的各个版本与 DirectX 版本的对应关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shader Model 1.0（DirectX8.0）&lt;/li&gt;
&lt;li&gt;Shader Model 2.0（DirectX9.0b）&lt;/li&gt;
&lt;li&gt;Shader Model 3.0（DirectX9.0c）&lt;/li&gt;
&lt;li&gt;Shader Model 4.0（DirectX10）&lt;/li&gt;
&lt;li&gt;Shader Model 4.1（DirectX10.1）&lt;/li&gt;
&lt;li&gt;Shader Model 5.0（DirectX11）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们先不关注各个版本区别，只要知道版本号越高，提供的功能越来越强大。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;GPU 为大量图形计算而生，而 Shader 是对 GPU 编程的技术。微软用 Shader Model 的不同版本号来区分不同 Shader 的能力。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Graphics_processing_unit"&gt;Wikipidia: Graphics processing unit &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/gp/product/1568814240?tag=realtimerenderin&amp;amp;pldnSite=1"&gt;&lt;em&gt;Real-Time Rendering, Third Edition&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://baike.baidu.com/link?url=DDy0sTi56RE9TiVdj5MOCqwmV7ATJEkBHQp7V8eRzA_lyq1HPOLgmBULeSo-Khw2-mb7Wst75LJF3_I3SjZAZa"&gt;Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;系列文章目录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.shuiguzi.com/xia-liao-unity3d-shader-xi-lie-zhi-yi-gpu-yu-shader-model.html"&gt;瞎聊 Unity3D Shader 系列之一：GPU 与 Shader Model&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Shader"></category></entry><entry><title>在Unity3d uGUI中绘制圆形图片</title><link href="http://blog.shuiguzi.com/zai-unity3d-uguizhong-hui-zhi-yuan-xing-tu-pian.html" rel="alternate"></link><updated>2015-04-15T23:30:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-04-15:zai-unity3d-uguizhong-hui-zhi-yuan-xing-tu-pian.html</id><summary type="html">&lt;p&gt;最近项目需要在 Unity3D 的新 UI 系统中实现圆形头像的功能，之前想通过 Mask 控件的方式来实现，但是一番努力后毫无头绪，只能祭上shader了。&lt;/p&gt;
&lt;p&gt;大体的思路就是在一个空的 Object 上面挂上 RawImage 组件，组件的 Material 挂上本文中的 shader。截取的逻辑是选取图片正中心 (0.5, 0.5) 为圆的中心点，绘制图片在圆内的像素点为图片的像素，然后图片在圆外的像素点设置为 alpha 为 0 的点，
如 &lt;code&gt;(0, 0, 0, 0)&lt;/code&gt;。逻辑是在 fragment shader 里面实现(shader 代码中的&lt;code&gt;frag&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下面直接放出 shader:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Shader&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Sprites/Circle&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;Properties&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;PerRendererData&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Sprite Texture&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;white&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;_Color&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Tint&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Color&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Center&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Radius Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Horizontal Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
    &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Vertical Scale&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;SubShader&lt;/span&gt;
  &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Tags&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;Queue&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Overlay&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;IgnoreProjector&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;RenderType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Transparent&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;PreviewType&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Plane&amp;quot;&lt;/span&gt;
      &lt;span class="s"&gt;&amp;quot;CanUseSpriteAtlas&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;True&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;Cull&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Lighting&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;ZWrite&lt;/span&gt; &lt;span class="n"&gt;Off&lt;/span&gt;
    &lt;span class="n"&gt;Blend&lt;/span&gt; &lt;span class="n"&gt;One&lt;/span&gt; &lt;span class="n"&gt;OneMinusSrcAlpha&lt;/span&gt;

    &lt;span class="n"&gt;Pass&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CGPROGRAM&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma vertex vert&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma fragment frag&lt;/span&gt;
      &lt;span class="cp"&gt;#pragma multi_compile _ PIXELSNAP_ON&lt;/span&gt;
      &lt;span class="cp"&gt;#include &amp;quot;UnityCG.cginc&amp;quot;&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="kt"&gt;appdata_t&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;v2f&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="nl"&gt;vertex&lt;/span&gt;   &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_POSITION&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="nl"&gt;color&lt;/span&gt;    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;COLOR&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;half2&lt;/span&gt; &lt;span class="nl"&gt;texcoord&lt;/span&gt;  &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;TEXCOORD0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;};&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="n"&gt;float4&lt;/span&gt; &lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="nf"&gt;vert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;appdata_t&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UNITY_MATRIX_MVP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_Color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="cp"&gt;#ifdef PIXELSNAP_ON&lt;/span&gt;
        &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UnityPixelSnap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="cp"&gt;#endif&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;OUT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;

      &lt;span class="n"&gt;sampler2D&lt;/span&gt; &lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

      &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;frag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v2f&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;SV_Target&lt;/span&gt;
      &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;fixed4&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tex2D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_MainTex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="c1"&gt;// adjust center and horizontal/verital scale&lt;/span&gt;
        &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="n"&gt;float2&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_HorizontalScale&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_VerticalScale&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;_Center&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;texcoord&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xy&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_RadiusScale&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;

          &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;ENDCG&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Github 地址： &lt;a href="https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader"&gt;https://raw.githubusercontent.com/wudixiaop/Nana/master/Shader/Sprite-Circle.shader&lt;/a&gt;&lt;/p&gt;</summary><category term="Unity3D"></category></entry><entry><title>一个例子学习Swift中的闭包用法</title><link href="http://blog.shuiguzi.com/yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html" rel="alternate"></link><updated>2015-03-26T15:37:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-03-26:yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</id><summary type="html">&lt;p&gt;初学习Swift, 觉得Swift中的闭包用法比较灵活, 所以在学习的时候编了个小例子来把用法罗列了出来, 分享出来给大家。&lt;/p&gt;
&lt;p&gt;在讲例子之前我们来看下什么是闭包(Closure).《The Swift Programming Language》是这样定义的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Closures are self-contained blocks of functionality that can be passed around and used in your code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文版中这样翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看解释我们知道，闭包是代码段，它能实现一些逻辑（函数），它可以被传递和使用（就像类型一样）。&lt;/p&gt;
&lt;p&gt;然后我们来看看闭包长的什么样子。下面是闭包的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ (parameters) -&amp;gt; returnType in
   statements
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面定义中 &lt;strong&gt;parameters&lt;/strong&gt; 是指参数， &lt;strong&gt;returnType&lt;/strong&gt; 是返回类型，而 &lt;strong&gt;statements&lt;/strong&gt; 指的是我们要实现的逻辑的代码, 闭包的代码都被 &lt;strong&gt;{}&lt;/strong&gt; 包含着。
观察力强的同学们估计发现了，它怎么跟Swift的函数长的差不多，难道它们是亲戚? Swift中函数是一种特殊的闭包，记住函数是闭包，不是闭包是函数哦。&lt;/p&gt;
&lt;p&gt;接下来我们说说文章开头提到的那个栗子。&lt;/p&gt;
&lt;p&gt;假设我们要找出某一些人中最小年龄是多少，我们要通过排序的方法来得到这个年龄。有这么一组年龄数字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;ages&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先我们使用最原始的办法，自己定义排序方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中我们定义了一个叫做 sortAge 的函数, 它传递给了第二个参数的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Bool&lt;/code&gt; 的 sorted 函数。 如果用闭包来代替自定义的函数, 写法就变成了这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个闭包用法就写好了。上面闭包中，定义了参数的个数，名字还有其类型，定义了返回值，还有代码体(in 关键词之后的代码)。
看起来就像重新写了一个 sortAage 函数。你可能会想，这样也没省多少事，只不过是把自定义的函数写到了 sorted 函数的参数里而已。
别急, 学会聪明的偷懒是一个好程序员属性，我们来看看怎么简化上面的代码。&lt;/p&gt;
&lt;p&gt;首先&lt;strong&gt;闭包中如果能从上下文推断出其参数类型，我们可以省略其类型的定义&lt;/strong&gt;。sorted 函数的, 所以我们可以简化代码为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，用来包含参数的括号我们可以省略掉, 变成了下面这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包代码体中只包含单行代码, 我们可以省略 return 关键词&lt;/strong&gt;, 然后变成了这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包中返回类型能从上下文推断出，我们可以省略返回值定义&lt;/strong&gt;。参照上面 sorted 函数第二个参数的定义，是可以推断出闭包返回值是 Bool。省略之后就变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到了这里，代码已经比较清爽了。但是偷懒的步伐还可以继续（懒惰是人类文明进化的动力）。Swift 闭包中允许用 $0, $1 $2 这样用 $n 这种符号后面接数字的形式来表示其第n个参数. 然后就可以变成这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，已经很短了。人类的偷懒的方法是无止境的。Swift中定义了运算符函数 &lt;code&gt;&amp;gt;&lt;/code&gt;, 我们可以把它传递给 sorted 函数。于是乎变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你还想问有没有更偷懒的方法？我只想说，兄台你醒醒吧，都只要输入一个字符而已了，你还要怎么样。。。&lt;/p&gt;
&lt;p&gt;除了上面的一些用法外，还有一种叫做尾随闭包（就是跟在调用它的函数的屁股后面的闭包），当调用它的函数的最后一个参数是闭包时，可以使用。我们可以把&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成尾随闭包形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大概就这些。。。&lt;/p&gt;</summary><category term="Swift"></category></entry><entry><title>如何在Github for Mac/Windows上使用非Github的仓库</title><link href="http://blog.shuiguzi.com/ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html" rel="alternate"></link><updated>2015-01-28T16:54:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-01-28:ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</id><summary type="html">&lt;p&gt;你或许跟我一样，不想花太多时间去"精通"git的各种命令，想用简单明了的方法来玩git。而Github的客户端恰是这种良药。使用过的童鞋可能有过跟我一样困惑：Github客户端在界面上只能管理Github的代码仓库，怎么才能管理非Github的仓库呢？&lt;/p&gt;
&lt;p&gt;这个问题也就是本文要解决的内容。先讲Github for Mac, 然后是Github for Windows&lt;/p&gt;
&lt;h3&gt;Github for Mac&lt;/h3&gt;
&lt;p&gt;首先创建一个本地的仓库, 假设取名为&lt;strong&gt;Freekick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_1" src="images/GitClient/mac_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后把git仓库的https地址设置为&lt;strong&gt;Freekick&lt;/strong&gt;仓库的&lt;strong&gt;Primary remote repository&lt;/strong&gt;。在&lt;strong&gt;Settings&lt;/strong&gt;选项卡中设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_2" src="images/GitClient/mac_2.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;上一步完成之后点击&lt;strong&gt;Updae Remote&lt;/strong&gt;按钮，之后会弹出输入账号密码的对话框。输入正确的账号密码即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_3" src="images/GitClient/mac_3.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后切换到&lt;strong&gt;Changes&lt;/strong&gt;选项卡，点击右上角的&lt;strong&gt;publish&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_4" src="images/GitClient/mac_4.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;最后Github for Mac会自动同步仓库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_5" src="images/GitClient/mac_5.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;Github for Windows&lt;/h3&gt;
&lt;p&gt;在Windows上只需要把git仓库的https地址拖拽到Github for Windows客户端上，然后会弹出对话框。输入正确的账号密码后，Github for Windows会自动同步代码。拖拽的时候最好把浏览器窗户缩小，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="windows_1" src="images/GitClient/windows_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;Github客户端不能本地创建新的仓库，然后发布到除Github之外的代码托管服务器上。如果需要新建一个仓库，我们可以先创建好一个空的新仓库，然后再用本文提到的方法来同步仓库来达到目的。&lt;/p&gt;
&lt;p&gt;另外，由于Github客户端是为Github量身定做的，当管理非Github仓库时，会有少量跟github相关的功能不能用。但是个人觉得这个不影响体验。我们可以通过下面的地址在官方下载Github客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github for Windows:&lt;/strong&gt; &lt;a href="https://windows.github.com/"&gt;https://windows.github.com/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Github for Mac:&lt;/strong&gt; &lt;a href="https://mac.github.com/"&gt;https://mac.github.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Git"></category></entry><entry><title>从C#到Python</title><link href="http://blog.shuiguzi.com/cong-cdao-python.html" rel="alternate"></link><updated>2015-01-07T20:13:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-01-07:cong-cdao-python.html</id><summary type="html">&lt;p&gt;项目组最近可能要用Python写一插件，虽然自己只是会用，但是还是被要求给大家做个简单的Python入门培训。只能冲个胖子，硬着头皮上了。
由于项目组里大部分童鞋们都会C#，可能如果从C#做类比的角度来阐述Python语法会更好点，然后下面奇怪的Python教程出来了。大家可以在这里得到PPT和代码:  &lt;a href="https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start"&gt;https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是讲语法的代码，语法部分在注释中有描述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- encoding:utf-8 -*-&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;本代码主要展示Python的基本数据类型和语法, 及其用法，希望可以帮助大家快速入门。&lt;/span&gt;
&lt;span class="sd"&gt;如果不是C#程序员, 请忽略‘C#伪代码’, 直接通过参考‘Python规则’部分来学习&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;




&lt;span class="c"&gt;# ---------------------------------注释----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 注释&lt;/span&gt;

&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    1. 用#打头表示注释&lt;/span&gt;
&lt;span class="sd"&gt;    2. 用三引号的字符串块，也可以表示注释（因为编译器会忽略3引号的块）&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;



&lt;span class="c"&gt;# -----------------------------------赋值-------------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 赋值&lt;/span&gt;

&lt;span class="sd"&gt;Python规则: &lt;/span&gt;
&lt;span class="sd"&gt;    Python是动态语言，变量类型在赋值阶段决定，不像其他语言一样需要先声明变量的数据类型(如C#).&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码: &lt;/span&gt;
&lt;span class="sd"&gt;    string var_sample = &amp;quot;something&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_sample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;someting&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#变量var_sample是字符串类型&lt;/span&gt;




&lt;span class="c"&gt;# ------------------------------Python基本数据类型-----------------------------------------------&lt;/span&gt;
&lt;span class="c"&gt;#   1. 空, 用None表示。&lt;/span&gt;
&lt;span class="c"&gt;#   2. 布尔类型: &lt;/span&gt;
&lt;span class="c"&gt;#   3. 数值类型。&lt;/span&gt;
&lt;span class="c"&gt;#   4. 字符串&lt;/span&gt;
&lt;span class="c"&gt;#   5. 列表, 也就是数组。&lt;/span&gt;
&lt;span class="c"&gt;#   6. 字典&lt;/span&gt;
&lt;span class="c"&gt;#   7. 集合(set)，无序的，不重复的元素集。&lt;/span&gt;
&lt;span class="c"&gt;#   8. 元组(Tuple), 和列表类似，但是一旦初始化就不能改变。&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 空  -----------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    空类型用None表示, 类似C#中的null.&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T s = null; // T表示可空类型&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_none&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 布尔类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    True和False. 对应C#中的true和false。&lt;/span&gt;
&lt;span class="sd"&gt;    基本类型中空、任何数值类型中的0、空字符串、空元组()、空列表[]、空字典{}都被当作 False.&lt;/span&gt;
&lt;span class="sd"&gt;    布尔运算有3中not, and和or, 他们的优先级是 not &amp;gt; and &amp;gt; or&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool1 = true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool2 = false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool3 = 3 &amp;gt; 2;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool4 = !true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool5 = true &amp;amp;&amp;amp; true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool6 = true || false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool7 = false || ((!false) &amp;amp;&amp;amp; true);&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_bool1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;        &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;    &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# 变量值为 True&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 数值类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    数值类型包括整型(int)和浮点数(float)&lt;/span&gt;
&lt;span class="sd"&gt;    整型前缀0b表示二机制，0O表示八进制，0X表示十六进制&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    int var_int = 1;&lt;/span&gt;
&lt;span class="sd"&gt;    int var_binary = Convert.ToInt32(&amp;quot;0010&amp;quot;, 2);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_octal = Convert.ToInt32(&amp;quot;0010&amp;quot;, 8);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_hex = 0x0010;&lt;/span&gt;
&lt;span class="sd"&gt;    double var_float = 1.0; // 或者 float var_float = 1.0;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;var_binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;b0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为2&lt;/span&gt;
&lt;span class="n"&gt;var_octal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;O0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为8, 0O第二个是字母O&lt;/span&gt;
&lt;span class="n"&gt;var_hex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为16&lt;/span&gt;
&lt;span class="n"&gt;var_float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 字符串  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字符串有多种表示方法，可以是&lt;/span&gt;
&lt;span class="sd"&gt;    1. 单引号&lt;/span&gt;
&lt;span class="sd"&gt;    2. 双引号&lt;/span&gt;
&lt;span class="sd"&gt;    3. 三引号, 字符串块，如果没有赋值给变量，会被编译器忽略，在这种情况下可以拿来当注释用&lt;/span&gt;

&lt;span class="sd"&gt;    字符串可以带r前缀，表示raw string, 不用转义&lt;/span&gt;
&lt;span class="sd"&gt;    字符串可以带u前缀，表示Unicode编码&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str2 = &amp;quot;some string&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str3 = @&amp;quot;C:\mydir\file.txt&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str4 = @&amp;quot;C:\mydir\文件.txt&amp;quot;; &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;var_str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some string&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;r&amp;quot;C:\mydir\file.txt&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;&amp;quot;&amp;quot;C:\mydir\文件.txt&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;#下面两种字符串格式是等价的&lt;/span&gt;
&lt;span class="n"&gt;var_str_fromat1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;var_str_format2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{0} {1}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 列表  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    列表，即数组, 用[]表示, 可以包含不同类型的元素。 C#中的数组或者List&amp;lt;&amp;gt;与其类似，但是C#必须指明元素数据类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的数组或List&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;  &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;       &lt;span class="c"&gt;# 索引下标从0开始，这段代码把第2位元素赋值为字符串&amp;#39;2&amp;#39;，取代了原来的整型2. 此时var_list值为 [1, &amp;#39;2&amp;#39;, [3]]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 添加一元素，此时var_list值为 [1, &amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 删除一元素，从头遍历，删除第一个元素1, 此时var_list值为 [&amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 继续删除1， 此时var_list值为 [&amp;#39;2&amp;#39;, [3]]&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 字典  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字典，用{}表示，可以用不同的类型做key和value, key和value之间用:号连接&lt;/span&gt;
&lt;span class="sd"&gt;    C#中的Dictionary&amp;lt;&amp;gt;和这个类似，但是C#必须指明Key和Value的类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的Dictionary&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello dictionary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 通过Key访问元素&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c"&gt;# 删除已元素，用del关键词&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 集合  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    集合(set)，是一个无序的，元素不重复的集，元素可以是不同类型。C#中的HashSet&amp;lt;&amp;gt;和这个类似，但是C#中必须指定类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的HashSet&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素, 此时var_set值为 set([1, &amp;#39;2&amp;#39;])&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 元组 -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    元组(Tuple), 用()表示，能包含不同类型元素。 和列表类似，但是一旦初始化就不能改变。C#中的Tuple&amp;lt;&amp;gt;和这个类似&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;   Tuple&amp;lt;int, int&amp;gt; var_tuple = new Tuple&amp;lt;int, int&amp;gt;(10, 20); &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_tuple_item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_tuple&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# 访问item, 下标从0开始&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------循环控制-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    python支持for和while循环&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    for(int i; i &amp;lt; 10; i ++) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        // do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    foeach(var item in List) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    int count = 0;&lt;/span&gt;
&lt;span class="sd"&gt;    while (count &amp;lt; 10)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        count += 1;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;


&lt;span class="c"&gt;# ------------------------------条件判断-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    条件判断 if, if-else, if-elif-else，或者包含多个elif的if-elif-elif...-else, 每个关键词后要带冒号&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    if (3 &amp;gt; 2) {}&lt;/span&gt;

&lt;span class="sd"&gt;    if (3 &amp;lt; 2)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    if ( 3 &amp;lt; 2 )&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 3)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 4)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------异常处理-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    关键词try...excpet&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       int i = 1/0; &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch(ZeroDivisionError)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ZeroDivisionError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------函数-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    函数用def来声明&lt;/span&gt;
&lt;span class="sd"&gt;    没有返回值声明，返回值由函数语句中的return来指明，并且可以有多个返回值。&lt;/span&gt;
&lt;span class="sd"&gt;    参数不需要带类型名字&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以赋值给变量&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以嵌套&lt;/span&gt;

&lt;span class="sd"&gt;    特别关注： 一些函数会用 *args和 **kwargs当作参数来表示可变参数：&lt;/span&gt;
&lt;span class="sd"&gt;        * --  以元组作为参数传入&lt;/span&gt;
&lt;span class="sd"&gt;        ** -- 以字典做为参数传入&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T test_function&amp;lt;T&amp;gt;(T a, T b)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        return a + b;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#的return 没有多返回值，且可变参方法不支持不同类型，这里不提供类比代码&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    按照python的风格，方法的注释用三引号字符块表示，并且方法函数声明与其&lt;/span&gt;
&lt;span class="sd"&gt;    第一行语句中间&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;var_test_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_function&lt;/span&gt; &lt;span class="c"&gt;# 函数可以赋值给变量&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 返回3&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回&amp;#39;12&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多个返回值&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    参数不确定时&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="n"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;上面语句输出为:&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;tuple&amp;#39;&amp;gt; (1, [1, &amp;#39;2&amp;#39;], 2)&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;dict&amp;#39;&amp;gt; {&amp;#39;a&amp;#39;: 3, &amp;#39;b&amp;#39;: [1, 2, 4, 5]}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# ------------------------------面向对象-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则&lt;/span&gt;
&lt;span class="sd"&gt;    类用关键词class表示&lt;/span&gt;
&lt;span class="sd"&gt;    类可以继承，并且支持多继承&lt;/span&gt;
&lt;span class="sd"&gt;    类的构造函数名字是固定的，名字是__init__, init前后是两个下划线&lt;/span&gt;
&lt;span class="sd"&gt;    类的析构函数名字也是固定的，名字是__del__&lt;/span&gt;
&lt;span class="sd"&gt;    实例方法第一参数名字必须是self,用于传递对象本身&lt;/span&gt;
&lt;span class="sd"&gt;    静态方法用@staticmethod装饰器表示，类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;    类方法用@classmethod装饰器表示，类似于C#中的类的静态方法&lt;/span&gt;
&lt;span class="sd"&gt;    子类同名的方法会覆盖父类同名方法&lt;/span&gt;
&lt;span class="sd"&gt;    多继承中，如果不同父类有有相同明名字的字段，则其值为最近一次所赋的值。&lt;/span&gt;

&lt;span class="sd"&gt;c#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    class Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public string msg;&lt;/span&gt;


&lt;span class="sd"&gt;        public Base(string msg)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            this.msg = msg;&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_class()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.Writeline(this.msg);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print something from Base&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    class Child : Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public Child : base(&amp;quot;Child&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;

&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public override void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print someting from Child&amp;quot;);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#不支持类的多继承&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        方法的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;        __init__()是构造函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        析构函数, 一般很少用&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base  {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;print something from Base&amp;#39;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    单继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        与父类同名，会覆盖父类的print_somthing方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print someting from Child&amp;quot;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base2 {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        静态方法, 要带@staticmethod装饰器, 类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;statc methond in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thiscls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        类方法，要带@classmethod装饰器，类似C#中的类的静态方法, 带一个参数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;class_method in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        访问父类方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access static methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access class methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access instance methond in parent class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类测试方法&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="c"&gt;# 多继承时，&lt;/span&gt;
    &lt;span class="c"&gt;#  1. 当不同的父类有相同的字段时, 其值为最近一次所赋的值&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="c"&gt;#  2. 当不同父类有相同方法时, 执行继承列表中的第一个父类的方法&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------模块与包-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    导入模块或包有好几种方式&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入：  import [moudle_name or package_name]&lt;/span&gt;
&lt;span class="sd"&gt;使用时要带上module_name或者package_name&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;module&lt;/span&gt;
&lt;span class="c"&gt;#print module.get_module_name()&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt;
&lt;span class="n"&gt;SamplePackage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addmodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种一： from [moudle_name or package name] import [...]&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;modemodule&lt;/span&gt; 
&lt;span class="n"&gt;modemodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种二： from [moudle_name or package name] import *  &lt;/span&gt;
&lt;span class="sd"&gt;*表示导入所有&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage.multiplymodule&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;__name__ 在默认情况下：&lt;/span&gt;
&lt;span class="sd"&gt;    1. 如果被自己模块内调用，它的值是 __main__&lt;/span&gt;
&lt;span class="sd"&gt;    2. 如果在外部模块调用，他的值是模块名字&lt;/span&gt;

&lt;span class="sd"&gt;所以我们可以把模块内部的测试代码放到下面代码中，不会影响其他模块&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码地址: &lt;a href="https://github.com/wudixiaop/Nana/blob/master/Python/Tutorial/Python%20Quick%20Start/PythonQuickStart/Python_Introduction.py"&gt;Github&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>如何在Visual Studio中愉快的玩耍</title><link href="http://blog.shuiguzi.com/ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html" rel="alternate"></link><updated>2014-12-24T14:50:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-12-24:ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</id><summary type="html">&lt;p&gt;好吧，其实我想要说一些我觉得可以在Visual Studio中提高效率的经验。下面直接进入正题：&lt;/p&gt;
&lt;h2&gt;熟记并使用各种快捷键&lt;/h2&gt;
&lt;p&gt;快捷键之所以叫快捷键就是因为它会让事情变得更快捷。好吧，其实我知道前面一句废话。下面就列举一些碰上常用的(基于Visual C# 2005快捷键映射)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注释: &lt;strong&gt;Ctrl + E, C&lt;/strong&gt; (也就是，先&lt;strong&gt;Ctrl&lt;/strong&gt;和&lt;strong&gt;E&lt;/strong&gt;一起摁，然后摁&lt;strong&gt;C&lt;/strong&gt;. 下面碰到有带组合键的情况类似)&lt;/li&gt;
&lt;li&gt;取消注释: &lt;strong&gt;Ctrl + E, U&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整行剪切: &lt;strong&gt;Ctrl + X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开光标所在行的概述(Outlining): &lt;strong&gt;Ctrl + M, M&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起概述(Outlining)到定义: &lt;strong&gt;Ctrl + M, O&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开所有概述(Outlining): &lt;strong&gt;Ctrl + M, L&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;呼出自动补全窗口: &lt;strong&gt;Ctrl + J&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;回跳到光标上一次所在位置: &lt;strong&gt;Ctrl + -&lt;/strong&gt; (这是减号)&lt;/li&gt;
&lt;li&gt;MSDN帮助: &lt;strong&gt;F1&lt;/strong&gt; (光标移到类名或者方法名上，然后摁&lt;strong&gt;F1&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;运行: &lt;strong&gt;F5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;编译: &lt;strong&gt;F6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;调试时Step Over/In: &lt;strong&gt;F10&lt;/strong&gt;/&lt;strong&gt;F11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跳转到定义: &lt;strong&gt;F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;搜索和替换窗口: &lt;strong&gt;Ctrl + Shift + F&lt;/strong&gt; 或者 &lt;strong&gt;Ctrl + Shift + H&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当然还有超级好用的自能感应: &lt;strong&gt;Ctrl + .&lt;/strong&gt; (或者&lt;strong&gt;Ctrl + Shift + F10&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然还有很多其他快捷，但是平时自己用的少，就不列举了。&lt;/p&gt;
&lt;h2&gt;偷懒技巧一：使用代码片段管理器(Code Snippets Manager)&lt;/h2&gt;
&lt;p&gt;如果还不知道有这个东西的童鞋可以在Vistual Studio的工具菜单中找到。具体怎么用大家可以参照别的童鞋们的文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/cyq1162/archive/2013/06/14/3135373.html"&gt;Visual Studio 小技巧：自定义代码片断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kb.cnblogs.com/page/42164/"&gt;使用Visual Studio Snippet(片断)提交开发效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单一句话描述Code Snippets使用就是：如果用C#举例，编写代码的时候，输入代码片段的快捷键(比如for), 然后摁两下Tab键，接下来就知道怎么做了。&lt;/p&gt;
&lt;p&gt;按惯例，列举一些C#常用的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;循环: &lt;strong&gt;for&lt;/strong&gt;, &lt;strong&gt;foreach&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成类: &lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成构造函数: &lt;strong&gt;ctor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成属性: &lt;strong&gt;prop&lt;/strong&gt;, &lt;strong&gt;propfull&lt;/strong&gt;, &lt;strong&gt;propdp&lt;/strong&gt;(Wpf系列中的依赖属性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;偷懒技巧二: Toolbox&lt;/h2&gt;
&lt;p&gt;文字看多了，咱们来看视频吧&lt;/p&gt;
&lt;iframe src="//channel9.msdn.com/Series/vstips/lazycodesnippets/player?format=html5" allowFullScreen frameBorder="0"&gt;&lt;/iframe&gt;

&lt;p&gt;视频源地址：&lt;a href="http://channel9.msdn.com/Series/vstips/lazycodesnippets"&gt;http://channel9.msdn.com/Series/vstips/lazycodesnippets&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;成为高手~~&lt;/h2&gt;
&lt;p&gt;不想成为标题党的程序员不是一个好写手。好吧，其实我是来推荐&lt;strong&gt;VsVim&lt;/strong&gt;这个插件的。。。&lt;/p&gt;
&lt;p&gt;首先，我们需要安装&lt;strong&gt;VsVim&lt;/strong&gt;。童鞋们可以在VS工具菜单下的扩展及更新(Extension and Updates)里查找并安装。具体可以参照这篇文章: &lt;a href="http://www.tuicool.com/articles/YF7RNv"&gt;http://www.tuicool.com/articles/YF7RNv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后开始练技能打怪练级:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://coolshell.cn/articles/5426.html"&gt;http://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jaredpar/VsVim/wiki/faq"&gt;https://github.com/jaredpar/VsVim/wiki/faq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再然后会慢慢发现平时编码时摸鼠标的次数越来少。。。&lt;/p&gt;
&lt;p&gt;再然后。。。没有再然后了。。&lt;/p&gt;</summary><category term="Visual Studio"></category></entry><entry><title>一起看看MonoBehavior内部事件执行顺序</title><link href="http://blog.shuiguzi.com/yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html" rel="alternate"></link><updated>2014-12-23T18:20:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-11-10:yi-qi-kan-kan-monobehaviornei-bu-shi-jian-zhi-xing-shun-xu.html</id><summary type="html">&lt;h3&gt;&lt;strong&gt;写在最前面&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;或许对于大部分Unity3D程序员来说，第一次接触脚本编写的时候都是从MonoBehavior开始的。MonoBehavior是Uniy3d脚本编写核心的类之一， 它预先定义好了很多事件，并且这些事件按照预先定义好顺序执行。了解MonoBehavior提供的这些事件的执行顺序，是我们进一步提高脚步编程和了解Unity3D内部逻辑的必要一步。我们先从MonoBehavior提供的事件说起。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;MonoBehavior都提供了什么事件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MonoBehavior提供的事件从编辑器到游戏结束都有涉及。下面列举一些常用的，更详列表可以参照&lt;a href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.html"&gt;这个页面&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与编辑相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Reset&lt;/td&gt;
            &lt;td&gt;Reset to default values.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;FixedUpdate&lt;/td&gt;
            &lt;td&gt;This function is called every fixed framerate frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Update&lt;/td&gt;
            &lt;td&gt;Update is called every frame, if the MonoBehaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;LateUpdate&lt;/td&gt;
            &lt;td&gt;LateUpdate is called every frame, if the Behaviour is enabled.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生命周期相关&lt;/strong&gt;&lt;br /&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;Awake&lt;/td&gt;
            &lt;td&gt;Awake is called when the script instance is being loaded.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnEnable&lt;/td&gt;
            &lt;td&gt;This function is called when the object becomes enabled and active.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDisable&lt;/td&gt;
            &lt;td&gt;This function is called when the behaviour becomes disabled () or inactive.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDestroy&lt;/td&gt;
            &lt;td&gt;This function is called when the MonoBehaviour will be destroyed.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationFocus&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player gets or loses focus.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationPause&lt;/td&gt;
            &lt;td&gt;Sent to all game objects when the player pauses.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnApplicationQuit&lt;/td&gt;
            &lt;td&gt;Sent to all game objects before the application is quit.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Start&lt;/td&gt;
            &lt;td&gt;Start is called on the frame when a script is enabled just before any of the Update methods is called the first time.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;物理系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter&lt;/td&gt;
            &lt;td&gt;OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay&lt;/td&gt;
            &lt;td&gt;OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit&lt;/td&gt;
            &lt;td&gt;OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when an incoming collider makes contact with this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where a collider on another object is touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnCollisionExit2D&lt;/td&gt;
            &lt;td&gt;Sent when a collider on another object stops touching this object's collider (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter&lt;/td&gt;
            &lt;td&gt;OnTriggerEnter is called when the Collider other enters the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay&lt;/td&gt;
            &lt;td&gt;OnTriggerStay is called once per frame for every Collider other that is touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit&lt;/td&gt;
            &lt;td&gt;OnTriggerExit is called when the Collider other has stopped touching the trigger.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerEnter2D&lt;/td&gt;
            &lt;td&gt;Sent when another object enters a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerStay2D&lt;/td&gt;
            &lt;td&gt;Sent each frame where another object is within a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnTriggerExit2D&lt;/td&gt;
            &lt;td&gt;Sent when another object leaves a trigger collider attached to this object (2D physics only).&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入系统相关&lt;/strong&gt;
&lt;table class="table table-striped  table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDown&lt;/td&gt;
            &lt;td&gt;OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseOver&lt;/td&gt;
            &lt;td&gt;OnMouseOver is called every frame while the mouse is over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUp&lt;/td&gt;
            &lt;td&gt;OnMouseUp is called when the user has released the mouse button.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseDrag&lt;/td&gt;
            &lt;td&gt;OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseEnter&lt;/td&gt;
            &lt;td&gt;OnMouseEnter is called when the mouse entered the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseExit&lt;/td&gt;
            &lt;td&gt;OnMouseExit is called when the mouse is not any longer over the GUIElement or Collider.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnMouseUpAsButton&lt;/td&gt;
            &lt;td&gt;OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渲染相关&lt;/strong&gt;
&lt;table class="table table-striped table-hover"&gt;
    &lt;theader&gt;
        &lt;th&gt;名称&lt;/th&gt;
        &lt;th&gt;注释&lt;/th&gt;
    &lt;/theader&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreCull&lt;/td&gt;
            &lt;td&gt;OnPreCull is called before a camera culls the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameVisible&lt;/td&gt;
            &lt;td&gt;OnBecameVisible is called when the renderer became visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnBecameInvisible&lt;/td&gt;
            &lt;td&gt;OnBecameInvisible is called when the renderer is no longer visible by any camera.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnWillRenderObject&lt;/td&gt;
            &lt;td&gt;OnWillRenderObject is called once for each camera if the object is visible.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPreRender&lt;/td&gt;
            &lt;td&gt;OnPreRender is called before a camera starts rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderObject&lt;/td&gt;
            &lt;td&gt;OnRenderObject is called after camera has rendered the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnPostRender&lt;/td&gt;
            &lt;td&gt;OnPostRender is called after a camera finished rendering the scene.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnRenderImage&lt;/td&gt;
            &lt;td&gt;OnRenderImage is called after all rendering is complete to render image.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnGUI&lt;/td&gt;
            &lt;td&gt;OnGUI is called for rendering and handling GUI events.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;OnDrawGizmos&lt;/td&gt;
            &lt;td&gt;Implement OnDrawGizmos if you want to draw gizmos that are also pickable and always drawn.&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;用图来表示MonoBehavior事件执行顺序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="monobehavior" src="images/monobehaviour_flowchart.svg" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首次加载场景时执行&lt;strong&gt;Awake()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Start()&lt;/strong&gt;只在第一帧才执行, &lt;strong&gt;Start()&lt;/strong&gt;在&lt;strong&gt;Awake()&lt;/strong&gt;之后执行&lt;/li&gt;
&lt;li&gt;Update的执行顺序是: &lt;strong&gt;FixedUpdate()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Update()&lt;/strong&gt; -&amp;gt; &lt;strong&gt;LateUpdate()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;以每一帧的&lt;strong&gt;Update()&lt;/strong&gt;事件作分界线：  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Update()之前&lt;/strong&gt;：&lt;strong&gt;物理系统&lt;/strong&gt;和&lt;strong&gt;输入系统&lt;/strong&gt;相关事件先执行，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;和&lt;strong&gt;OnMouseXXX&lt;/strong&gt;事件。此处&lt;strong&gt;XXX&lt;/strong&gt;是占位符，如&lt;strong&gt;OnTriggerXXX&lt;/strong&gt;可以代表&lt;strong&gt;OnTriggerEnter&lt;/strong&gt;或者&lt;strong&gt;OnTriggerExit&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Update()之后&lt;/strong&gt;：&lt;strong&gt;场景渲染&lt;/strong&gt;和&lt;strong&gt;协程&lt;/strong&gt;，如&lt;strong&gt;OnRenderImage()&lt;/strong&gt;和&lt;strong&gt;yield WWW&lt;/strong&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协程中，除了&lt;strong&gt;WaitForFixedUpdate&lt;/strong&gt;是在&lt;strong&gt;FixedUpdate&lt;/strong&gt;之后，&lt;strong&gt;Update&lt;/strong&gt;之前执行，其他的都是在&lt;strong&gt;Update&lt;/strong&gt;之后，&lt;strong&gt;场景渲染&lt;/strong&gt;前执行&lt;/li&gt;
&lt;li&gt;GUI事件&lt;strong&gt;OnGUI&lt;/strong&gt;在场景渲染完之后执行&lt;/li&gt;
&lt;li&gt;当对象被销毁时执行&lt;strong&gt;OnDestory()&lt;/strong&gt;事件&lt;/li&gt;
&lt;li&gt;当游戏退出时执行&lt;strong&gt;OnApplicationQuit()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;和&lt;strong&gt;OnDisable()&lt;/strong&gt;  &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OnEnable()&lt;/strong&gt;只有在Object是Active的状态下才能用，一般是Object被初始化或者Object从disable到active过程中被调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OnDisable()&lt;/strong&gt;只有到Object从active到disable状态才被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Unity3D"></category></entry><entry><title>关于Unity3D编辑器一些事儿</title><link href="http://blog.shuiguzi.com/guan-yu-unity3dbian-ji-qi-yi-xie-shi-er.html" rel="alternate"></link><updated>2014-11-05T22:30:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-11-05:guan-yu-unity3dbian-ji-qi-yi-xie-shi-er.html</id><summary type="html">&lt;p&gt;这里描述下Unity3D编辑器使用过程中遇到的坑及其解决方法&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件一：Unity3d编辑器启动时默认打开最近一次打开的项目&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;默认设置中，Unity3D启动时会自动打开默认最近一次打开的项目。每当只想打开小项目，而偏偏上次打开过一个大项目时，这点让人很抓狂。&lt;br /&gt;
&lt;strong&gt;解决方法:&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在编辑器中打开&lt;strong&gt;Unity Preferences&lt;/strong&gt;窗口,通过 &lt;strong&gt;Edit-&amp;gt;Preferences...&lt;/strong&gt;打开&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;General&lt;/strong&gt;选项卡中把&lt;strong&gt;Always Show Project Wizard&lt;/strong&gt;勾选上&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;事件二：Project Wizard中最近打开项目记录删除不了&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一直不明白为啥不让删除呢？  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：&lt;/strong&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法一：让项目地址失效&lt;/strong&gt;  &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;重名名项目文件夹&lt;/li&gt;
&lt;li&gt;把项目移动到别的文件夹&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法二：修改注册表&lt;/strong&gt;  &lt;blockquote&gt;
&lt;p&gt;删除 HKEY_CURRENT_USER\Software\Unity Technologies\Unity Editor 4.x 下面以 RecentlyUsedProjectPaths 开头的项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;以后继续补充...&lt;/p&gt;</summary><category term="Unity3D"></category></entry><entry><title>ShaderlabVS Release Page</title><link href="http://blog.shuiguzi.com/shaderlabvs-release-page.html" rel="alternate"></link><updated>2014-10-28T21:20:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-10-28:shaderlabvs-release-page.html</id><summary type="html">&lt;h2&gt;&lt;em&gt;Latest Version - V0.5&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-28] V0.5 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add braces matching&lt;/li&gt;
&lt;li&gt;Add outlining&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.5/ShaderlabVS-0.5.zip"&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1qW9aR5E"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;A introduction of ShaderlabVS can be found at &lt;a href="https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md"&gt;https://github.com/wudixiaop/ShaderlabVS/blob/master/README.md&lt;/a&gt;. If you have feedbacks or questions, send email to me. My email is rockylai@qq.com.&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;&lt;em&gt;Screenshot&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="preview" src="https://github.com/wudixiaop/ShaderlabVS/raw/master/img/Highlighting.PNG" width="100%"/&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;em&gt;History:&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;[2014-10-19] V0.4 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Add support for .cginc and .glslinc file&lt;/li&gt;
&lt;li&gt;Add more keywords support&lt;/li&gt;
&lt;li&gt;Syntax highlighting is case insensitive now&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.4/ShaderlabVS.zip"&gt;Github Relase Page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1o6sPOUI"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;V0.3 release note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support Signature help feature&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Download:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/wudixiaop/ShaderlabVS/releases/download/0.3/ShaderlabVS-0.3.zip"&gt;Github Release page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pan.baidu.com/s/1eQEJQHO"&gt;BaiduPan&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary><category term="Shader"></category></entry><entry><title>Why I start ShaderlabVS</title><link href="http://blog.shuiguzi.com/why-i-start-shaderlabvs.html" rel="alternate"></link><updated>2010-10-19T18:09:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-08-31:why-i-start-shaderlabvs.html</id><summary type="html">&lt;p&gt;Last month, &lt;a href="http://unityvs.com/"&gt;SyntaxTree&lt;/a&gt;, the creator of UnityVS plugin for Visual Studio was acquired by Microsoft. Microsoft have published the UnityVS to Visual Studio users for free at the end of July.&lt;/p&gt;
&lt;p&gt;UnityVS is cool tool that make it's possible to debug Unity3D scripts in VS. But the tool is not support the Unity3D shaderlab syntax. it's pain for me to to read/write shader in VS, So I created the ShaderlabVS to help myself and may would help someone who need it.&lt;/p&gt;</summary><category term="Shader"></category></entry></feed>