<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>心亡则忙，亡心则忘</title><link href="http://blog.shuiguzi.com/" rel="alternate"></link><link href="http://blog.shuiguzi.com/feeds/yi-dian-yi-di.atom.xml" rel="self"></link><id>http://blog.shuiguzi.com/</id><updated>2015-07-21T12:54:00+08:00</updated><entry><title>好玩：如何把 Github Contributions 填充满</title><link href="http://blog.shuiguzi.com/hao-wan-ru-he-ba-github-contributions-tian-chong-man.html" rel="alternate"></link><updated>2015-07-21T12:54:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-07-21:hao-wan-ru-he-ba-github-contributions-tian-chong-man.html</id><summary type="html">&lt;p&gt;先看效果：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="rockstar" src="images/RockStar/rockstar.PNG" width="78%" /&gt;&lt;/p&gt;
&lt;p&gt;我们要使用 RockStar 这个 python 工具来实现这个效果。RockStar 的 Github 地址 &lt;a href="https://github.com/avinassh/rockstar"&gt;撮这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;RockStar 只支持 Python 3，不能在 Python 2 上面。如果本机没有 Pyhon3 可以从 &lt;a href="http://python.org"&gt;http://python.org&lt;/a&gt; 里面下载安装，当前版本的下载地址为 &lt;a href="https://www.python.org/downloads/release/python-343/"&gt;https://www.python.org/downloads/release/python-343/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;使用 python 前我们需要在环境变量中加入 python3 的安装路径和脚本文件的路径。假如我们安装在 &lt;code&gt;C:\Python34&lt;/code&gt; 文件夹下，则加入下面地址到环境变量 &lt;code&gt;PATH&lt;/code&gt; 中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C:\Python34;C:\Python34\Scripts&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面设置完成之后我们就可以用 python 来玩耍啦。首先我们打开命令行来安装 RockStar ，输入&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pip install rockstar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入完成之后, 我们创建一个新文件夹，比如叫做 RSFunny, 并在这个文件夹下面创建一个 python 脚本，比如叫做 rockstar.py。 脚步的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;RockStar&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;RockStar&lt;/span&gt;

&lt;span class="n"&gt;csharp_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;using System;&lt;/span&gt;

&lt;span class="s"&gt;class HelloWorld&lt;/span&gt;
&lt;span class="s"&gt;{&lt;/span&gt;
&lt;span class="s"&gt;    static void Main()&lt;/span&gt;
&lt;span class="s"&gt;    {&lt;/span&gt;
&lt;span class="s"&gt;        Console.WriteLine(&amp;quot;I&amp;#39;m Rocky&amp;quot;);&lt;/span&gt;
&lt;span class="s"&gt;    }&lt;/span&gt;
&lt;span class="s"&gt;}&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# 400 天&lt;/span&gt;
&lt;span class="n"&gt;rock_it_bro&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RockStar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;rockstar.cs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;csharp_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;rock_it_bro&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make_me_a_rockstar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多的例子我们能参考这里 &lt;a href="https://github.com/avinassh/rockstar/tree/master/examples"&gt;https://github.com/avinassh/rockstar/tree/master/examples&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;接下来，在命令行中跳转到到 RSFunny 目录下, 准备运行 rockstar.py。这里需要注意一下，因为脚本需要用到 git.exe，所以我们需要把 git.exe 的路径加入到当前的环境变量 &lt;code&gt;PATH&lt;/code&gt; 中，不然会抛出找不到文件的错误。
如果安装了 Github for Windows 客户端，我们可以从客户端的安装目录 &lt;code&gt;%AppData%\..\Local\GitHub&lt;/code&gt; 下找到 git.exe。添加完后，我们运行脚本：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;python rockstar.py&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行完后，脚本将 RSFunny 目录变成一个 git 仓库。&lt;/p&gt;
&lt;p&gt;好了，万事具备，只欠发布到 Github 了。 建议使用最新版 Github for Windows 客户端，简单快捷，居家旅行必备。。。&lt;/p&gt;
&lt;p&gt;不知道怎么在 Github for Windows 客户端添加？ 那就点点左上角的 + 号，然后结合下面这个截图看看，相信应有收获的。 :) &lt;/p&gt;
&lt;p&gt;&lt;img alt="gitAddRepo" src="images/RockStar/gitAddRepo.PNG" width="72%" /&gt;&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>一个例子学习Swift中的闭包用法</title><link href="http://blog.shuiguzi.com/yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html" rel="alternate"></link><updated>2015-03-26T15:37:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-03-26:yi-ge-li-zi-xue-xi-swiftzhong-de-bi-bao-yong-fa.html</id><summary type="html">&lt;p&gt;初学习Swift, 觉得Swift中的闭包用法比较灵活, 所以在学习的时候编了个小例子来把用法罗列了出来, 分享出来给大家。&lt;/p&gt;
&lt;p&gt;在讲例子之前我们来看下什么是闭包(Closure).《The Swift Programming Language》是这样定义的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Closures are self-contained blocks of functionality that can be passed around and used in your code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文版中这样翻译：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包是自包含的函数代码块，可以在代码中被传递和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看解释我们知道，闭包是代码段，它能实现一些逻辑（函数），它可以被传递和使用（就像类型一样）。&lt;/p&gt;
&lt;p&gt;然后我们来看看闭包长的什么样子。下面是闭包的定义:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{ (parameters) -&amp;gt; returnType in
   statements
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面定义中 &lt;strong&gt;parameters&lt;/strong&gt; 是指参数， &lt;strong&gt;returnType&lt;/strong&gt; 是返回类型，而 &lt;strong&gt;statements&lt;/strong&gt; 指的是我们要实现的逻辑的代码, 闭包的代码都被 &lt;strong&gt;{}&lt;/strong&gt; 包含着。
观察力强的同学们估计发现了，它怎么跟Swift的函数长的差不多，难道它们是亲戚? Swift中函数是一种特殊的闭包，记住函数是闭包，不是闭包是函数哦。&lt;/p&gt;
&lt;p&gt;接下来我们说说文章开头提到的那个栗子。&lt;/p&gt;
&lt;p&gt;假设我们要找出某一些人中最小年龄是多少，我们要通过排序的方法来得到这个年龄。有这么一组年龄数字:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;ages&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;首先我们使用最原始的办法，自己定义排序方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sortAge&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码中我们定义了一个叫做 sortAge 的函数, 它传递给了第二个参数的类型是 &lt;code&gt;(Int, Int) -&amp;gt; Bool&lt;/code&gt; 的 sorted 函数。 如果用闭包来代替自定义的函数, 写法就变成了这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个闭包用法就写好了。上面闭包中，定义了参数的个数，名字还有其类型，定义了返回值，还有代码体(in 关键词之后的代码)。
看起来就像重新写了一个 sortAage 函数。你可能会想，这样也没省多少事，只不过是把自定义的函数写到了 sorted 函数的参数里而已。
别急, 学会聪明的偷懒是一个好程序员属性，我们来看看怎么简化上面的代码。&lt;/p&gt;
&lt;p&gt;首先&lt;strong&gt;闭包中如果能从上下文推断出其参数类型，我们可以省略其类型的定义&lt;/strong&gt;。sorted 函数的, 所以我们可以简化代码为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，用来包含参数的括号我们可以省略掉, 变成了下面这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包代码体中只包含单行代码, 我们可以省略 return 关键词&lt;/strong&gt;, 然后变成了这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果&lt;strong&gt;闭包中返回类型能从上下文推断出，我们可以省略返回值定义&lt;/strong&gt;。参照上面 sorted 函数第二个参数的定义，是可以推断出闭包返回值是 Bool。省略之后就变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;age1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;age2&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到了这里，代码已经比较清爽了。但是偷懒的步伐还可以继续（懒惰是人类文明进化的动力）。Swift 闭包中允许用 $0, $1 $2 这样用 $n 这种符号后面接数字的形式来表示其第n个参数. 然后就可以变成这个样子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，已经很短了。人类的偷懒的方法是无止境的。Swift中定义了运算符函数 &lt;code&gt;&amp;gt;&lt;/code&gt;, 我们可以把它传递给 sorted 函数。于是乎变成了这个样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你还想问有没有更偷懒的方法？我只想说，兄台你醒醒吧，都只要输入一个字符而已了，你还要怎么样。。。&lt;/p&gt;
&lt;p&gt;除了上面的一些用法外，还有一种叫做尾随闭包（就是跟在调用它的函数的屁股后面的闭包），当调用它的函数的最后一个参数是闭包时，可以使用。我们可以把&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写成尾随闭包形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nv"&gt;$0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;大概就这些。。。&lt;/p&gt;</summary><category term="Swift"></category></entry><entry><title>如何在Github for Mac/Windows上使用非Github的仓库</title><link href="http://blog.shuiguzi.com/ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html" rel="alternate"></link><updated>2015-01-28T16:54:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-01-28:ru-he-zai-github-for-macwindowsshang-shi-yong-fei-githubde-cang-ku.html</id><summary type="html">&lt;p&gt;你或许跟我一样，不想花太多时间去"精通"git的各种命令，想用简单明了的方法来玩git。而Github的客户端恰是这种良药。使用过的童鞋可能有过跟我一样困惑：Github客户端在界面上只能管理Github的代码仓库，怎么才能管理非Github的仓库呢？&lt;/p&gt;
&lt;p&gt;这个问题也就是本文要解决的内容。先讲Github for Mac, 然后是Github for Windows&lt;/p&gt;
&lt;h3&gt;Github for Mac&lt;/h3&gt;
&lt;p&gt;首先创建一个本地的仓库, 假设取名为&lt;strong&gt;Freekick&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_1" src="images/GitClient/mac_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后把git仓库的https地址设置为&lt;strong&gt;Freekick&lt;/strong&gt;仓库的&lt;strong&gt;Primary remote repository&lt;/strong&gt;。在&lt;strong&gt;Settings&lt;/strong&gt;选项卡中设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_2" src="images/GitClient/mac_2.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;上一步完成之后点击&lt;strong&gt;Updae Remote&lt;/strong&gt;按钮，之后会弹出输入账号密码的对话框。输入正确的账号密码即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_3" src="images/GitClient/mac_3.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;然后切换到&lt;strong&gt;Changes&lt;/strong&gt;选项卡，点击右上角的&lt;strong&gt;publish&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_4" src="images/GitClient/mac_4.png" width="100%"/&gt;&lt;/p&gt;
&lt;p&gt;最后Github for Mac会自动同步仓库。&lt;/p&gt;
&lt;p&gt;&lt;img alt="mac_5" src="images/GitClient/mac_5.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;Github for Windows&lt;/h3&gt;
&lt;p&gt;在Windows上只需要把git仓库的https地址拖拽到Github for Windows客户端上，然后会弹出对话框。输入正确的账号密码后，Github for Windows会自动同步代码。拖拽的时候最好把浏览器窗户缩小，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="windows_1" src="images/GitClient/windows_1.png" width="100%"/&gt;&lt;/p&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;Github客户端不能本地创建新的仓库，然后发布到除Github之外的代码托管服务器上。如果需要新建一个仓库，我们可以先创建好一个空的新仓库，然后再用本文提到的方法来同步仓库来达到目的。&lt;/p&gt;
&lt;p&gt;另外，由于Github客户端是为Github量身定做的，当管理非Github仓库时，会有少量跟github相关的功能不能用。但是个人觉得这个不影响体验。我们可以通过下面的地址在官方下载Github客户端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github for Windows:&lt;/strong&gt; &lt;a href="https://windows.github.com/"&gt;https://windows.github.com/&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Github for Mac:&lt;/strong&gt; &lt;a href="https://mac.github.com/"&gt;https://mac.github.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Git"></category></entry><entry><title>从C#到Python</title><link href="http://blog.shuiguzi.com/cong-cdao-python.html" rel="alternate"></link><updated>2015-01-07T20:13:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2015-01-07:cong-cdao-python.html</id><summary type="html">&lt;p&gt;项目组最近可能要用Python写一插件，虽然自己只是会用，但是还是被要求给大家做个简单的Python入门培训。只能冲个胖子，硬着头皮上了。
由于项目组里大部分童鞋们都会C#，可能如果从C#做类比的角度来阐述Python语法会更好点，然后下面奇怪的Python教程出来了。大家可以在这里得到PPT和代码:  &lt;a href="https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start"&gt;https://github.com/wudixiaop/Nana/tree/master/Python/Tutorial/Python%20Quick%20Start&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面是讲语法的代码，语法部分在注释中有描述。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- encoding:utf-8 -*-&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;本代码主要展示Python的基本数据类型和语法, 及其用法，希望可以帮助大家快速入门。&lt;/span&gt;
&lt;span class="sd"&gt;如果不是C#程序员, 请忽略‘C#伪代码’, 直接通过参考‘Python规则’部分来学习&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;




&lt;span class="c"&gt;# ---------------------------------注释----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 注释&lt;/span&gt;

&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    1. 用#打头表示注释&lt;/span&gt;
&lt;span class="sd"&gt;    2. 用三引号的字符串块，也可以表示注释（因为编译器会忽略3引号的块）&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;



&lt;span class="c"&gt;# -----------------------------------赋值-------------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;语法 - 赋值&lt;/span&gt;

&lt;span class="sd"&gt;Python规则: &lt;/span&gt;
&lt;span class="sd"&gt;    Python是动态语言，变量类型在赋值阶段决定，不像其他语言一样需要先声明变量的数据类型(如C#).&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码: &lt;/span&gt;
&lt;span class="sd"&gt;    string var_sample = &amp;quot;something&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_sample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;someting&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#变量var_sample是字符串类型&lt;/span&gt;




&lt;span class="c"&gt;# ------------------------------Python基本数据类型-----------------------------------------------&lt;/span&gt;
&lt;span class="c"&gt;#   1. 空, 用None表示。&lt;/span&gt;
&lt;span class="c"&gt;#   2. 布尔类型: &lt;/span&gt;
&lt;span class="c"&gt;#   3. 数值类型。&lt;/span&gt;
&lt;span class="c"&gt;#   4. 字符串&lt;/span&gt;
&lt;span class="c"&gt;#   5. 列表, 也就是数组。&lt;/span&gt;
&lt;span class="c"&gt;#   6. 字典&lt;/span&gt;
&lt;span class="c"&gt;#   7. 集合(set)，无序的，不重复的元素集。&lt;/span&gt;
&lt;span class="c"&gt;#   8. 元组(Tuple), 和列表类似，但是一旦初始化就不能改变。&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 空  -----------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    空类型用None表示, 类似C#中的null.&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T s = null; // T表示可空类型&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_none&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 布尔类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    True和False. 对应C#中的true和false。&lt;/span&gt;
&lt;span class="sd"&gt;    基本类型中空、任何数值类型中的0、空字符串、空元组()、空列表[]、空字典{}都被当作 False.&lt;/span&gt;
&lt;span class="sd"&gt;    布尔运算有3中not, and和or, 他们的优先级是 not &amp;gt; and &amp;gt; or&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool1 = true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool2 = false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool3 = 3 &amp;gt; 2;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool4 = !true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool5 = true &amp;amp;&amp;amp; true;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool6 = true || false;&lt;/span&gt;
&lt;span class="sd"&gt;    bool var_bool7 = false || ((!false) &amp;amp;&amp;amp; true);&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_bool1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;        &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;    &lt;span class="c"&gt;# 变量值为False&lt;/span&gt;
&lt;span class="n"&gt;var_bool5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# 变量值为True&lt;/span&gt;
&lt;span class="n"&gt;var_bool7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# 变量值为 True&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 数值类型  --------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    数值类型包括整型(int)和浮点数(float)&lt;/span&gt;
&lt;span class="sd"&gt;    整型前缀0b表示二机制，0O表示八进制，0X表示十六进制&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    int var_int = 1;&lt;/span&gt;
&lt;span class="sd"&gt;    int var_binary = Convert.ToInt32(&amp;quot;0010&amp;quot;, 2);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_octal = Convert.ToInt32(&amp;quot;0010&amp;quot;, 8);&lt;/span&gt;
&lt;span class="sd"&gt;    int var_hex = 0x0010;&lt;/span&gt;
&lt;span class="sd"&gt;    double var_float = 1.0; // 或者 float var_float = 1.0;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;var_binary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mb"&gt;0b0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为2&lt;/span&gt;
&lt;span class="n"&gt;var_octal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;O0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为8, 0O第二个是字母O&lt;/span&gt;
&lt;span class="n"&gt;var_hex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x0010&lt;/span&gt; &lt;span class="c"&gt;# 变量值为16&lt;/span&gt;
&lt;span class="n"&gt;var_float&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 字符串  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字符串有多种表示方法，可以是&lt;/span&gt;
&lt;span class="sd"&gt;    1. 单引号&lt;/span&gt;
&lt;span class="sd"&gt;    2. 双引号&lt;/span&gt;
&lt;span class="sd"&gt;    3. 三引号, 字符串块，如果没有赋值给变量，会被编译器忽略，在这种情况下可以拿来当注释用&lt;/span&gt;

&lt;span class="sd"&gt;    字符串可以带r前缀，表示raw string, 不用转义&lt;/span&gt;
&lt;span class="sd"&gt;    字符串可以带u前缀，表示Unicode编码&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str2 = &amp;quot;some string&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str3 = @&amp;quot;C:\mydir\file.txt&amp;quot;;&lt;/span&gt;
&lt;span class="sd"&gt;    string var_str4 = @&amp;quot;C:\mydir\文件.txt&amp;quot;; &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;some string&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;var_str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;some string&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;r&amp;quot;C:\mydir\file.txt&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_str4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;&amp;quot;&amp;quot;C:\mydir\文件.txt&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;#下面两种字符串格式是等价的&lt;/span&gt;
&lt;span class="n"&gt;var_str_fromat1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;var_str_format2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;{0} {1}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;-----------------------  数据类型 - 列表  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则：&lt;/span&gt;
&lt;span class="sd"&gt;    列表，即数组, 用[]表示, 可以包含不同类型的元素。 C#中的数组或者List&amp;lt;&amp;gt;与其类似，但是C#必须指明元素数据类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的数组或List&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;  &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;       &lt;span class="c"&gt;# 索引下标从0开始，这段代码把第2位元素赋值为字符串&amp;#39;2&amp;#39;，取代了原来的整型2. 此时var_list值为 [1, &amp;#39;2&amp;#39;, [3]]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 添加一元素，此时var_list值为 [1, &amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 删除一元素，从头遍历，删除第一个元素1, 此时var_list值为 [&amp;#39;2&amp;#39;, [3], 1]&lt;/span&gt;
&lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c"&gt;# 继续删除1， 此时var_list值为 [&amp;#39;2&amp;#39;, [3]]&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 字典  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    字典，用{}表示，可以用不同的类型做key和value, key和value之间用:号连接&lt;/span&gt;
&lt;span class="sd"&gt;    C#中的Dictionary&amp;lt;&amp;gt;和这个类似，但是C#必须指明Key和Value的类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的Dictionary&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。  &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello dictionary&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 通过Key访问元素&lt;/span&gt;
&lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;var_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="c"&gt;# 删除已元素，用del关键词&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 集合  -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    集合(set)，是一个无序的，元素不重复的集，元素可以是不同类型。C#中的HashSet&amp;lt;&amp;gt;和这个类似，但是C#中必须指定类型&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    C#的HashSet&amp;lt;&amp;gt;不能包含不同类型的元素，这里不提供类比代码。&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 添加一元素&lt;/span&gt;
&lt;span class="n"&gt;var_set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 添加一元素, 此时var_set值为 set([1, &amp;#39;2&amp;#39;])&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;----------------------- 数据类型 - 元组 -------------------------------------- &lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    元组(Tuple), 用()表示，能包含不同类型元素。 和列表类似，但是一旦初始化就不能改变。C#中的Tuple&amp;lt;&amp;gt;和这个类似&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;   Tuple&amp;lt;int, int&amp;gt; var_tuple = new Tuple&amp;lt;int, int&amp;gt;(10, 20); &lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;var_tuple&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="n"&gt;var_tuple_item&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;var_tuple&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c"&gt;# 访问item, 下标从0开始&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------循环控制-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    python支持for和while循环&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    for(int i; i &amp;lt; 10; i ++) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        // do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    foeach(var item in List) &lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //do something&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    int count = 0;&lt;/span&gt;
&lt;span class="sd"&gt;    while (count &amp;lt; 10)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        count += 1;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;var_list&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;

&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;


&lt;span class="c"&gt;# ------------------------------条件判断-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    条件判断 if, if-else, if-elif-else，或者包含多个elif的if-elif-elif...-else, 每个关键词后要带冒号&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    if (3 &amp;gt; 2) {}&lt;/span&gt;

&lt;span class="sd"&gt;    if (3 &amp;lt; 2)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    if ( 3 &amp;lt; 2 )&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 3)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else if (3 &amp;lt; 4)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    else&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;         //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------异常处理-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    关键词try...excpet&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;       int i = 1/0; &lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    try&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;    catch(ZeroDivisionError)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        //pass&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ZeroDivisionError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------函数-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    函数用def来声明&lt;/span&gt;
&lt;span class="sd"&gt;    没有返回值声明，返回值由函数语句中的return来指明，并且可以有多个返回值。&lt;/span&gt;
&lt;span class="sd"&gt;    参数不需要带类型名字&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以赋值给变量&lt;/span&gt;
&lt;span class="sd"&gt;    函数可以嵌套&lt;/span&gt;

&lt;span class="sd"&gt;    特别关注： 一些函数会用 *args和 **kwargs当作参数来表示可变参数：&lt;/span&gt;
&lt;span class="sd"&gt;        * --  以元组作为参数传入&lt;/span&gt;
&lt;span class="sd"&gt;        ** -- 以字典做为参数传入&lt;/span&gt;

&lt;span class="sd"&gt;C#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    T test_function&amp;lt;T&amp;gt;(T a, T b)&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        return a + b;&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#的return 没有多返回值，且可变参方法不支持不同类型，这里不提供类比代码&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    按照python的风格，方法的注释用三引号字符块表示，并且方法函数声明与其&lt;/span&gt;
&lt;span class="sd"&gt;    第一行语句中间&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="n"&gt;var_test_function&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test_function&lt;/span&gt; &lt;span class="c"&gt;# 函数可以赋值给变量&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 返回3&lt;/span&gt;
&lt;span class="n"&gt;var_test_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回&amp;#39;12&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多个返回值&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;three&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;four&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;five&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;multi_return_value_function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    参数不确定时&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;kwargs&lt;/span&gt;

&lt;span class="n"&gt;multi_params_fuction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;上面语句输出为:&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;tuple&amp;#39;&amp;gt; (1, [1, &amp;#39;2&amp;#39;], 2)&lt;/span&gt;
&lt;span class="sd"&gt;&amp;lt;type &amp;#39;dict&amp;#39;&amp;gt; {&amp;#39;a&amp;#39;: 3, &amp;#39;b&amp;#39;: [1, 2, 4, 5]}&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# ------------------------------面向对象-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则&lt;/span&gt;
&lt;span class="sd"&gt;    类用关键词class表示&lt;/span&gt;
&lt;span class="sd"&gt;    类可以继承，并且支持多继承&lt;/span&gt;
&lt;span class="sd"&gt;    类的构造函数名字是固定的，名字是__init__, init前后是两个下划线&lt;/span&gt;
&lt;span class="sd"&gt;    类的析构函数名字也是固定的，名字是__del__&lt;/span&gt;
&lt;span class="sd"&gt;    实例方法第一参数名字必须是self,用于传递对象本身&lt;/span&gt;
&lt;span class="sd"&gt;    静态方法用@staticmethod装饰器表示，类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;    类方法用@classmethod装饰器表示，类似于C#中的类的静态方法&lt;/span&gt;
&lt;span class="sd"&gt;    子类同名的方法会覆盖父类同名方法&lt;/span&gt;
&lt;span class="sd"&gt;    多继承中，如果不同父类有有相同明名字的字段，则其值为最近一次所赋的值。&lt;/span&gt;

&lt;span class="sd"&gt;c#伪代码:&lt;/span&gt;
&lt;span class="sd"&gt;    class Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public string msg;&lt;/span&gt;


&lt;span class="sd"&gt;        public Base(string msg)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            this.msg = msg;&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_class()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.Writeline(this.msg);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public virtual void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print something from Base&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    class Child : Base&lt;/span&gt;
&lt;span class="sd"&gt;    {&lt;/span&gt;
&lt;span class="sd"&gt;        public Child : base(&amp;quot;Child&amp;quot;)&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;

&lt;span class="sd"&gt;        }&lt;/span&gt;

&lt;span class="sd"&gt;        public override void print_somthing()&lt;/span&gt;
&lt;span class="sd"&gt;        {&lt;/span&gt;
&lt;span class="sd"&gt;            Console.WriteLine(&amp;quot;print someting from Child&amp;quot;);&lt;/span&gt;
&lt;span class="sd"&gt;        }&lt;/span&gt;
&lt;span class="sd"&gt;    }&lt;/span&gt;

&lt;span class="sd"&gt;    C#不支持类的多继承&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        方法的注释放到这里&lt;/span&gt;
&lt;span class="sd"&gt;        __init__()是构造函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__del__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        析构函数, 一般很少用&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base  {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;print something from Base&amp;#39;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    单继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        与父类同名，会覆盖父类的print_somthing方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;print someting from Child&amp;quot;&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;base2 {0}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    多继承&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Child2Base2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 访问父类构造函数&lt;/span&gt;

    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        静态方法, 要带@staticmethod装饰器, 类似于一个全局的函数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;statc methond in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thiscls&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        类方法，要带@classmethod装饰器，类似C#中的类的静态方法, 带一个参数&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;class_method in Child2&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;        访问父类方法&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access static methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access class methond in class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;access instance methond in parent class&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;    类测试方法&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;static_method&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;Child2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class_methond&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_somthing&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_child2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;


    &lt;span class="c"&gt;# 多继承时，&lt;/span&gt;
    &lt;span class="c"&gt;#  1. 当不同的父类有相同的字段时, 其值为最近一次所赋的值&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;

    &lt;span class="c"&gt;#  2. 当不同父类有相同方法时, 执行继承列表中的第一个父类的方法&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_class&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;



&lt;span class="c"&gt;# ------------------------------模块与包-----------------------------------------------&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;Python规则:&lt;/span&gt;
&lt;span class="sd"&gt;    导入模块或包有好几种方式&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入：  import [moudle_name or package_name]&lt;/span&gt;
&lt;span class="sd"&gt;使用时要带上module_name或者package_name&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;module&lt;/span&gt;
&lt;span class="c"&gt;#print module.get_module_name()&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt;
&lt;span class="n"&gt;SamplePackage&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addmodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种一： from [moudle_name or package name] import [...]&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;modemodule&lt;/span&gt; 
&lt;span class="n"&gt;modemodule&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;导入变种二： from [moudle_name or package name] import *  &lt;/span&gt;
&lt;span class="sd"&gt;*表示导入所有&lt;/span&gt;
&lt;span class="sd"&gt;使用时可以省略module_name或者package_name直接访问&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SamplePackage.multiplymodule&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="sd"&gt;__name__ 在默认情况下：&lt;/span&gt;
&lt;span class="sd"&gt;    1. 如果被自己模块内调用，它的值是 __main__&lt;/span&gt;
&lt;span class="sd"&gt;    2. 如果在外部模块调用，他的值是模块名字&lt;/span&gt;

&lt;span class="sd"&gt;所以我们可以把模块内部的测试代码放到下面代码中，不会影响其他模块&lt;/span&gt;
&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;oop_test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面代码地址: &lt;a href="https://github.com/wudixiaop/Nana/blob/master/Python/Tutorial/Python%20Quick%20Start/PythonQuickStart/Python_Introduction.py"&gt;Github&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>如何在Visual Studio中愉快的玩耍</title><link href="http://blog.shuiguzi.com/ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html" rel="alternate"></link><updated>2014-12-24T14:50:00+08:00</updated><author><name>Rocky Lai</name></author><id>tag:blog.shuiguzi.com,2014-12-24:ru-he-zai-visual-studiozhong-yu-kuai-de-wan-shua.html</id><summary type="html">&lt;p&gt;好吧，其实我想要说一些我觉得可以在Visual Studio中提高效率的经验。下面直接进入正题：&lt;/p&gt;
&lt;h3&gt;熟记并使用各种快捷键&lt;/h3&gt;
&lt;p&gt;快捷键之所以叫快捷键就是因为它会让事情变得更快捷。好吧，其实我知道前面一句废话。下面就列举一些碰上常用的(基于Visual C# 2005快捷键映射)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;注释: &lt;strong&gt;Ctrl + E, C&lt;/strong&gt; (也就是，先&lt;strong&gt;Ctrl&lt;/strong&gt;和&lt;strong&gt;E&lt;/strong&gt;一起摁，然后摁&lt;strong&gt;C&lt;/strong&gt;. 下面碰到有带组合键的情况类似)&lt;/li&gt;
&lt;li&gt;取消注释: &lt;strong&gt;Ctrl + E, U&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整行剪切: &lt;strong&gt;Ctrl + X&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开光标所在行的概述(Outlining): &lt;strong&gt;Ctrl + M, M&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起概述(Outlining)到定义: &lt;strong&gt;Ctrl + M, O&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;收起/展开所有概述(Outlining): &lt;strong&gt;Ctrl + M, L&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;呼出自动补全窗口: &lt;strong&gt;Ctrl + J&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;回跳到光标上一次所在位置: &lt;strong&gt;Ctrl + -&lt;/strong&gt; (这是减号)&lt;/li&gt;
&lt;li&gt;MSDN帮助: &lt;strong&gt;F1&lt;/strong&gt; (光标移到类名或者方法名上，然后摁&lt;strong&gt;F1&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;运行: &lt;strong&gt;F5&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;编译: &lt;strong&gt;F6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;调试时Step Over/In: &lt;strong&gt;F10&lt;/strong&gt;/&lt;strong&gt;F11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跳转到定义: &lt;strong&gt;F12&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;搜索和替换窗口: &lt;strong&gt;Ctrl + Shift + F&lt;/strong&gt; 或者 &lt;strong&gt;Ctrl + Shift + H&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当然还有超级好用的自能感应: &lt;strong&gt;Ctrl + .&lt;/strong&gt; (或者&lt;strong&gt;Ctrl + Shift + F10&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然还有很多其他快捷，但是平时自己用的少，就不列举了。&lt;/p&gt;
&lt;h3&gt;偷懒技巧一：使用代码片段管理器(Code Snippets Manager)&lt;/h3&gt;
&lt;p&gt;如果还不知道有这个东西的童鞋可以在Vistual Studio的工具菜单中找到。具体怎么用大家可以参照别的童鞋们的文章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/cyq1162/archive/2013/06/14/3135373.html"&gt;Visual Studio 小技巧：自定义代码片断&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kb.cnblogs.com/page/42164/"&gt;使用Visual Studio Snippet(片断)提交开发效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单一句话描述Code Snippets使用就是：如果用C#举例，编写代码的时候，输入代码片段的快捷键(比如for), 然后摁两下Tab键，接下来就知道怎么做了。&lt;/p&gt;
&lt;p&gt;按惯例，列举一些C#常用的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;循环: &lt;strong&gt;for&lt;/strong&gt;, &lt;strong&gt;foreach&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成类: &lt;strong&gt;class&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成构造函数: &lt;strong&gt;ctor&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成属性: &lt;strong&gt;prop&lt;/strong&gt;, &lt;strong&gt;propfull&lt;/strong&gt;, &lt;strong&gt;propdp&lt;/strong&gt;(Wpf系列中的依赖属性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;偷懒技巧二: Toolbox&lt;/h3&gt;
&lt;p&gt;文字看多了，咱们来看视频吧&lt;/p&gt;
&lt;iframe src="//channel9.msdn.com/Series/vstips/lazycodesnippets/player?format=html5" allowFullScreen frameBorder="0"&gt;&lt;/iframe&gt;

&lt;p&gt;视频源地址：&lt;a href="http://channel9.msdn.com/Series/vstips/lazycodesnippets"&gt;http://channel9.msdn.com/Series/vstips/lazycodesnippets&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;成为高手~~&lt;/h3&gt;
&lt;p&gt;不想成为标题党的程序员不是一个好写手。好吧，其实我是来推荐&lt;strong&gt;VsVim&lt;/strong&gt;这个插件的。。。&lt;/p&gt;
&lt;p&gt;首先，我们需要安装&lt;strong&gt;VsVim&lt;/strong&gt;。童鞋们可以在VS工具菜单下的扩展及更新(Extension and Updates)里查找并安装。具体可以参照这篇文章: &lt;a href="http://www.tuicool.com/articles/YF7RNv"&gt;http://www.tuicool.com/articles/YF7RNv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后开始练技能打怪练级:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://coolshell.cn/articles/5426.html"&gt;http://coolshell.cn/articles/5426.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jaredpar/VsVim/wiki/faq"&gt;https://github.com/jaredpar/VsVim/wiki/faq&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再然后会慢慢发现平时编码时摸鼠标的次数越来少。。。&lt;/p&gt;
&lt;p&gt;再然后。。。没有再然后了。。&lt;/p&gt;</summary><category term="Visual Studio"></category></entry></feed>